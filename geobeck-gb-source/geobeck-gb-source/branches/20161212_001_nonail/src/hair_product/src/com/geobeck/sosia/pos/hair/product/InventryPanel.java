/*
 * InventryPanel.java
 *
 * Created on 2008/09/29, 13:08
 */

package com.geobeck.sosia.pos.hair.product;

import com.geobeck.sosia.pos.basicinfo.WorkTimePasswordDialog;
import com.geobeck.sosia.pos.basicinfo.commodity.EditabeTableCellRenderer;
import com.geobeck.sosia.pos.hair.data.commodity.DataInventory;
import com.geobeck.sosia.pos.hair.data.commodity.DataInventoryDetail;
import com.geobeck.sosia.pos.hair.product.beans.PrintInventoryProductBean;
import com.geobeck.sosia.pos.hair.product.logic.PrintInventoryLogic;
import com.geobeck.sosia.pos.master.commodity.MstSupplier;
import com.geobeck.sosia.pos.master.commodity.MstSuppliers;
import com.geobeck.sosia.pos.master.company.MstShop;
import com.geobeck.sosia.pos.master.product.MstItem;
import com.geobeck.sosia.pos.master.product.MstItemClass;
import com.geobeck.sosia.pos.master.product.MstItemClasses;
import com.geobeck.sosia.pos.swing.SelectTableCellRenderer;
import com.geobeck.sosia.pos.system.SystemInfo;
import com.geobeck.sosia.pos.util.MessageUtil;
import com.geobeck.swing.IntegerCellEditor;
import com.geobeck.swing.MessageDialog;
import com.geobeck.swing.SwingUtil;
import com.geobeck.sql.ConnectionWrapper;
import com.geobeck.sql.ResultSetWrapper;
import com.geobeck.util.SQLUtil;
import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.FocusTraversalPolicy;
import java.awt.Window;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;

/**
 *
 * @author  syouji
 */
public class InventryPanel extends com.geobeck.sosia.pos.swing.AbstractImagePanelEx
{
	/**
	 * FocusTraversalPolicy
	 */
	private	FocusTraversalPolicy traversalPolicy = 	new FocusTraversalPolicyImpl();

	/**
	 * FocusTraversalPolicyを取得する。
	 * @return FocusTraversalPolicy
	 */
	public FocusTraversalPolicy getFocusTraversalPolicy()
	{
		return	traversalPolicy;
	}

	private SearchInventry	si	=	new SearchInventry();
	private InventoryRecords	ir	=	new InventoryRecords();
	private DataInventory current_di = new DataInventory();
	private Date toDateTemp = null;
        //IVS_LVTu start add 2015/07/20 New request #40693
        PrintInventoryLogic inventoryLogic = new PrintInventoryLogic();
        //IVS_LVTu end add 2015/07/20 New request #40693

	/** Creates new form InventryPanel */
	public InventryPanel()
	{
		initComponents();
		addMouseCursorChange();
		this.setSize(850, 690);
		this.setPath("商品管理 >> 棚卸");
		this.setTitle("棚卸");
		this.setKeyListener();
		
		//店舗コンボボックス初期化
		SystemInfo.initGroupShopComponents(shop, 2);
		//仕入先コンボボックス初期化
		initSupplier();
		
		//デザイン用のボタンテキストを消去
		btnTempRegist.setText("");
		btnRegist.setText("");
		btnOutputExcel.setText("");
		btnShow.setText("");
		
		//既存の棚卸データ（ヘッダ）を読み込む
		loadInventoryHead();
		
		//棚卸期間の初期表示を行う
		setInventrySpan();
		
		inventryFrom.setEditable(false);
		
		status.setText("");
	}
	
	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        inventryUnit = new javax.swing.ButtonGroup();
        taxUnit = new javax.swing.ButtonGroup();
        itemUnit = new javax.swing.ButtonGroup();
        conditionUnit = new javax.swing.ButtonGroup();
        stockUnit = new javax.swing.ButtonGroup();
        shop = new com.geobeck.sosia.pos.swing.JComboBoxLabel();
        lblTax = new javax.swing.JLabel();
        rdoTaxUnit = new javax.swing.JRadioButton();
        rdoTaxBlank = new javax.swing.JRadioButton();
        shopLabel = new javax.swing.JLabel();
        dateLabel = new javax.swing.JLabel();
        inventryFrom = new jp.co.flatsoft.fscomponent.FSCalenderCombo();
        jLabel2 = new javax.swing.JLabel();
        inventryTo = new jp.co.flatsoft.fscomponent.FSCalenderCombo();
        jLabel3 = new javax.swing.JLabel();
        suppliersNo = new javax.swing.JTextField();
        suppliers = new javax.swing.JComboBox();
        lblInventry = new javax.swing.JLabel();
        rdoInventrySale = new javax.swing.JRadioButton();
        rdoInventryWork = new javax.swing.JRadioButton();
        dispLabel = new javax.swing.JLabel();
        rdoClass = new javax.swing.JRadioButton();
        rdoPlace = new javax.swing.JRadioButton();
        rdoConditionAll = new javax.swing.JRadioButton();
        rdoConditionDiff = new javax.swing.JRadioButton();
        rdoConditionNoDiff = new javax.swing.JRadioButton();
        btnShow = new javax.swing.JButton();
        btnTempRegist = new javax.swing.JButton();
        btnRegist = new javax.swing.JButton();
        inventryScrollPane = new javax.swing.JScrollPane();
        inventryTable = new com.geobeck.swing.JTableEx();
        summaryScrollPane = new javax.swing.JScrollPane();
        summaryTable = new com.geobeck.swing.JTableEx();
        btnOutputExcel = new javax.swing.JButton();
        status = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        rdoStockAll = new javax.swing.JRadioButton();
        rdoInStock = new javax.swing.JRadioButton();
        rdoOutOfStock = new javax.swing.JRadioButton();

        setBackground(new java.awt.Color(246, 246, 246));
        setFocusCycleRoot(true);

        shop.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        shop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                shopActionPerformed(evt);
            }
        });

        lblTax.setText("税区分");

        taxUnit.add(rdoTaxUnit);
        rdoTaxUnit.setSelected(true);
        rdoTaxUnit.setText("税込");
        rdoTaxUnit.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoTaxUnit.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoTaxUnit.setOpaque(false);

        taxUnit.add(rdoTaxBlank);
        rdoTaxBlank.setText("税抜");
        rdoTaxBlank.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoTaxBlank.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoTaxBlank.setOpaque(false);

        shopLabel.setText("店舗");

        dateLabel.setText("集計期間");

        inventryFrom.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));

        jLabel2.setText("〜");

        inventryTo.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        inventryTo.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                inventryToFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                inventryToFocusLost(evt);
            }
        });

        jLabel3.setText("仕入先");

        suppliersNo.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        suppliersNo.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                suppliersNoFocusLost(evt);
            }
        });

        suppliers.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        suppliers.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                suppliersActionPerformed(evt);
            }
        });

        lblInventry.setText("棚卸区分");

        inventryUnit.add(rdoInventrySale);
        rdoInventrySale.setText("店販用");
        rdoInventrySale.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoInventrySale.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoInventrySale.setOpaque(false);
        rdoInventrySale.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdoInventrySaleActionPerformed(evt);
            }
        });

        inventryUnit.add(rdoInventryWork);
        rdoInventryWork.setSelected(true);
        rdoInventryWork.setText("業務用");
        rdoInventryWork.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoInventryWork.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoInventryWork.setOpaque(false);
        rdoInventryWork.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdoInventryWorkActionPerformed(evt);
            }
        });

        dispLabel.setText("表示条件");

        itemUnit.add(rdoClass);
        rdoClass.setSelected(true);
        rdoClass.setText("分類");
        rdoClass.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoClass.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoClass.setOpaque(false);

        itemUnit.add(rdoPlace);
        rdoPlace.setText("置場");
        rdoPlace.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoPlace.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoPlace.setOpaque(false);

        conditionUnit.add(rdoConditionAll);
        rdoConditionAll.setSelected(true);
        rdoConditionAll.setText("全て");
        rdoConditionAll.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoConditionAll.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoConditionAll.setOpaque(false);

        conditionUnit.add(rdoConditionDiff);
        rdoConditionDiff.setText("過不足あり");
        rdoConditionDiff.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoConditionDiff.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoConditionDiff.setOpaque(false);

        conditionUnit.add(rdoConditionNoDiff);
        rdoConditionNoDiff.setText("過不足なし");
        rdoConditionNoDiff.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoConditionNoDiff.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoConditionNoDiff.setOpaque(false);

        btnShow.setIcon(SystemInfo.getImageIcon("/button/common/show_off.jpg"));
        btnShow.setText("表示");
        btnShow.setBorderPainted(false);
        btnShow.setContentAreaFilled(false);
        btnShow.setPressedIcon(SystemInfo.getImageIcon("/button/common/show_on.jpg"));
        btnShow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnShowActionPerformed(evt);
            }
        });

        btnTempRegist.setIcon(SystemInfo.getImageIcon("/button/account/tempAccount_off.jpg"));
        btnTempRegist.setText("一時保存");
        btnTempRegist.setBorderPainted(false);
        btnTempRegist.setContentAreaFilled(false);
        btnTempRegist.setFocusable(false);
        btnTempRegist.setPressedIcon(SystemInfo.getImageIcon("/button/account/tempAccount_on.jpg"));
        btnTempRegist.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTempRegistActionPerformed(evt);
            }
        });

        btnRegist.setIcon(SystemInfo.getImageIcon("/button/common/regist_off.jpg"));
        btnRegist.setText("登録");
        btnRegist.setBorderPainted(false);
        btnRegist.setContentAreaFilled(false);
        btnRegist.setFocusable(false);
        btnRegist.setPressedIcon(SystemInfo.getImageIcon("/button/common/regist_on.jpg"));
        btnRegist.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRegistActionPerformed(evt);
            }
        });

        inventryTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "分類／置場", "商品名", "仕入価格", "期首", "入庫数", "添付数", "入庫金額", "出庫数", "出庫金額", "帳簿在庫", "実在庫数", "過不足数", "在庫金額", "過不足金額"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.Long.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Long.class, java.lang.Integer.class, java.lang.Long.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Long.class, java.lang.Long.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, false, true, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        inventryTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        inventryTable.setInheritsPopupMenu(true);
        inventryTable.setSelectionBackground(new java.awt.Color(255, 210, 142));
        inventryTable.setSelectionForeground(new java.awt.Color(0, 0, 0));
        // 列の並び替え禁止
        inventryTable.getTableHeader().setReorderingAllowed(false);
        // ヘッダのレンダラを設定
        SwingUtil.setJTableHeaderRenderer(inventryTable, SystemInfo.getTableHeaderRenderer());
        inventryTable.setRowHeight(SystemInfo.TABLE_ROW_HEIGHT);
        this.initTableColumnWidth();
        SelectTableCellRenderer.setSelectTableCellRenderer(inventryTable);

        TableColumnModel model = inventryTable.getColumnModel();
        model.getColumn(10).setCellRenderer(new EditabeTableCellRenderer(Integer.class));
        model.getColumn(10).setCellEditor(new IntegerCellEditor(new JTextField()));
        model.getColumn(11).setCellRenderer(new MinusCellRedRenderer());
        model.getColumn(13).setCellRenderer(new MinusCellRedRenderer());
        inventryTable.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                inventryTablePropertyChange(evt);
            }
        });
        inventryScrollPane.setViewportView(inventryTable);

        summaryScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        summaryScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        summaryTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "期首", "入庫数", "添付数", "入庫金額", "出庫数", "出庫金額", "帳簿在庫", "実在個数", "過不足数", "在庫金額", "過不足金額"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Long.class, java.lang.Integer.class, java.lang.Long.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Long.class, java.lang.Long.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        summaryTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        summaryTable.setSelectionBackground(new java.awt.Color(255, 210, 142));
        summaryTable.setSelectionForeground(new java.awt.Color(0, 0, 0));
        // 列の並び替え禁止
        summaryTable.getTableHeader().setReorderingAllowed(false);
        // ヘッダのレンダラを設定
        SwingUtil.setJTableHeaderRenderer(summaryTable, SystemInfo.getTableHeaderRenderer());
        summaryTable.setRowHeight(SystemInfo.TABLE_ROW_HEIGHT);
        this.initSummaryTableColumnWidth();
        SelectTableCellRenderer.setSelectTableCellRenderer(summaryTable);
        summaryTable.getColumnModel().getColumn(8).setCellRenderer(new MinusCellRedRenderer());
        summaryTable.getColumnModel().getColumn(10).setCellRenderer(new MinusCellRedRenderer());
        summaryScrollPane.setViewportView(summaryTable);

        btnOutputExcel.setIcon(SystemInfo.getImageIcon("/button/print/excel_off.jpg"));
        btnOutputExcel.setText("EXCEL");
        btnOutputExcel.setBorderPainted(false);
        btnOutputExcel.setContentAreaFilled(false);
        btnOutputExcel.setEnabled(false);
        btnOutputExcel.setFocusCycleRoot(true);
        btnOutputExcel.setPreferredSize(new java.awt.Dimension(81, 23));
        btnOutputExcel.setPressedIcon(SystemInfo.getImageIcon("/button/print/excel_on.jpg"));
        btnOutputExcel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOutputExcelActionPerformed(evt);
            }
        });

        status.setFont(new java.awt.Font("MS UI Gothic", 1, 15)); // NOI18N
        status.setForeground(java.awt.Color.blue);
        status.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        status.setText("【未登録】");

        jLabel6.setFont(new java.awt.Font("MS UI Gothic", 0, 13)); // NOI18N
        jLabel6.setForeground(java.awt.Color.red);
        jLabel6.setText("<html> ※仕入先での絞り込みをしている場合は、「一時保存」のみ可能です。<br> ※棚卸確定処理は仕入先を未選択にて「表示」後、「登録」を行ってください。<br> ※添付数は入庫金額に反映されませんが、出庫金額及び在庫金額には反映されます。<br> ※区分間の在庫移動は、それぞれの区分の入庫・出庫金額に加算されます。<br> ※入庫・出庫金額は、伝票登録時点での仕入価格となります。<br> ※「一時保存」「登録」を行った場合は、後から期間変更が行えませんのでご注意ください。<br> ※表示条件の「在庫あり」にした場合は、期首・入庫・出庫が0以外の商品が表示されます。<br> </html> ");
        jLabel6.setPreferredSize(new java.awt.Dimension(500, 98));

        stockUnit.add(rdoStockAll);
        rdoStockAll.setSelected(true);
        rdoStockAll.setText("全て");
        rdoStockAll.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoStockAll.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoStockAll.setOpaque(false);

        stockUnit.add(rdoInStock);
        rdoInStock.setText("在庫あり");
        rdoInStock.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoInStock.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoInStock.setOpaque(false);

        stockUnit.add(rdoOutOfStock);
        rdoOutOfStock.setText("在庫なし");
        rdoOutOfStock.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        rdoOutOfStock.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rdoOutOfStock.setOpaque(false);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(shopLabel)
                .addGap(34, 34, 34)
                .addComponent(shop, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(314, 314, 314)
                .addComponent(btnTempRegist, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(6, 6, 6)
                .addComponent(btnRegist, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(6, 6, 6)
                .addComponent(btnOutputExcel, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(jLabel3)
                .addGap(23, 23, 23)
                .addComponent(suppliersNo, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(6, 6, 6)
                .addComponent(suppliers, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblInventry)
                            .addComponent(dateLabel)
                            .addComponent(lblTax)))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(dispLabel)))
                .addGap(16, 16, 16)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(rdoInventrySale)
                        .addGap(9, 9, 9)
                        .addComponent(rdoInventryWork))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(inventryFrom, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(2, 2, 2)
                        .addComponent(jLabel2)
                        .addGap(9, 9, 9)
                        .addComponent(inventryTo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(rdoClass)
                            .addComponent(rdoStockAll)
                            .addComponent(rdoTaxUnit)
                            .addComponent(rdoConditionAll))
                        .addGap(11, 11, 11)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(rdoConditionDiff)
                            .addComponent(rdoPlace)
                            .addComponent(rdoTaxBlank, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rdoInStock))
                        .addGap(7, 7, 7)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(rdoOutOfStock)
                            .addComponent(rdoConditionNoDiff))))
                .addGap(30, 30, 30)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 491, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnShow, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(301, 301, 301)
                        .addComponent(status, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE))))
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(inventryScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 820, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addGap(221, 221, 221)
                .addComponent(summaryScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 588, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(11, 11, 11)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(1, 1, 1)
                        .addComponent(shopLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(shop, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnTempRegist, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnRegist, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnOutputExcel, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(3, 3, 3)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(suppliersNo, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(suppliers, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(1, 1, 1)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 146, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(3, 3, 3)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(btnShow, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(status, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(lblInventry, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(6, 6, 6)
                                .addComponent(dateLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(66, 66, 66)
                                .addComponent(lblTax, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(rdoInventrySale, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(rdoInventryWork, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(6, 6, 6)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(inventryFrom, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(inventryTo, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(6, 6, 6)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(rdoClass, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(dispLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGap(16, 16, 16)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(rdoStockAll, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(20, 20, 20)
                                                .addComponent(rdoTaxUnit, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(20, 20, 20)
                                        .addComponent(rdoConditionAll, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(20, 20, 20)
                                                .addComponent(rdoConditionDiff, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                            .addComponent(rdoPlace, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGap(16, 16, 16)
                                        .addComponent(rdoTaxBlank, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(40, 40, 40)
                                        .addComponent(rdoInStock, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(20, 20, 20)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(20, 20, 20)
                                                .addComponent(rdoOutOfStock, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))
                                            .addComponent(rdoConditionNoDiff, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE))))))))
                .addComponent(inventryScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 278, Short.MAX_VALUE)
                .addGap(6, 6, 6)
                .addComponent(summaryScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
    }// </editor-fold>//GEN-END:initComponents

	private void rdoInventryWorkActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_rdoInventryWorkActionPerformed
	{//GEN-HEADEREND:event_rdoInventryWorkActionPerformed
		reload(false);
	}//GEN-LAST:event_rdoInventryWorkActionPerformed

	private void rdoInventrySaleActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_rdoInventrySaleActionPerformed
	{//GEN-HEADEREND:event_rdoInventrySaleActionPerformed
		reload(false);
	}//GEN-LAST:event_rdoInventrySaleActionPerformed
	
	private void btnOutputExcelActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnOutputExcelActionPerformed
	{//GEN-HEADEREND:event_btnOutputExcelActionPerformed

            //出力処理
            btnOutputExcel.setCursor(null);

            try {

                setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
		generateInventory();
                
            } finally {
                setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
            }

	}//GEN-LAST:event_btnOutputExcelActionPerformed
	
	/**
	 * Excel出力ボタン
	 */	
	private void generateInventory()
	{
            MstShop shop = (MstShop)this.shop.getSelectedItem();
            MstSupplier supplier = (MstSupplier)this.suppliers.getSelectedItem();
            DateRange range = new DateRange();
            range.setFrom(inventryFrom.getDate());
            range.setTo(inventryTo.getDate());
            
            PrintInventoryLogic logic = new PrintInventoryLogic(shop, supplier);
            logic.setDateRange(range.getTo(), range.getFrom());

            if ( rdoInventrySale.isSelected() ) {
                logic.setInventory(PrintInventoryLogic.INVENTORY_FOR_SELL);
            } else {
                logic.setInventory(PrintInventoryLogic.INVENTORY_FOR_OPERATION);
            }
            if ( rdoTaxUnit.isSelected() ) {
                logic.setTaxCondition(PrintInventoryLogic.INVENTORY_WITH_TAX);
            } else {
                logic.setTaxCondition(PrintInventoryLogic.INVENTORY_WITHOU_TAX);
            }
            //IVS_LVTu start add 2015/07/20 New request #40693
            this.inventoryLogic = logic;
            getDataInventry();
            
            //IVS_LVTu end add 2015/07/20 New request #40693

            //IVS_LVTu start edit 2015/07/22 New request #40693
            //int result = logic.viewInventoryReport();
            int result = this.inventoryLogic.viewInventoryReport2();
            //IVS_LVTu start edit 2015/07/22 New request #40693
            if (result == logic.RESULT_SUCCESS ) {
                // 成功
            } else if(result == logic.RESULT_DATA_NOTHNIG ) {
                // データなし
                MessageDialog.showMessageDialog(this,
                        MessageUtil.getMessage(4001),
                        this.getTitle(),
                        JOptionPane.ERROR_MESSAGE);
            } else if(result == logic.RESULT_ERROR ) {
                // 予期せぬエラー
                MessageDialog.showMessageDialog( this,
                        MessageUtil.getMessage(1099),
                        this.getTitle(),
                        JOptionPane.ERROR_MESSAGE );
            }
	}
	
	/**
	 * 一時保存ボタン
	 */
    private void btnTempRegistActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTempRegistActionPerformed

        if (!checkInput()) return;

        //登録処理（確定しない）
        if (this.regist(false) > 0) {

            //登録しました
            MessageDialog.showMessageDialog(this,
                    MessageUtil.getMessage(201, ""),
                    this.getTitle(),
                    JOptionPane.INFORMATION_MESSAGE);

            if (ir.getCurrentInventry() == null) {
                //棚卸データ（ヘッダ）を読み込む
                loadInventoryHead();

                //棚卸期間の初期表示を行う
                setInventrySpan();

            } else {
                //現在選択されている棚卸データを維持
                Integer id = ir.getCurrentInventry().getInventoryId();

                //棚卸データ（ヘッダ）を読み込む
                loadInventoryHead();

                ir.setCurrentInventry(id);

            }
            //データの再表示
            this.searchInventry();
            this.showStatus();
            this.showInventry();
            this.showSummary();
            // 更新フラグを強制的に落とす
            si.setUpdate(false);

        } else {
            //登録失敗
            MessageDialog.showMessageDialog(this,
                    MessageUtil.getMessage(MessageUtil.ERROR_REGIST_FAILED, "棚卸"),
                    this.getTitle(),
                    JOptionPane.ERROR_MESSAGE);
        }
		
    }//GEN-LAST:event_btnTempRegistActionPerformed
	
	/**
	 * 実在庫数の入力更新
	 */
    private void inventryTablePropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_inventryTablePropertyChange
		this.changeInventry();
    }//GEN-LAST:event_inventryTablePropertyChange

	/**
	 * 表示ボタンクリック
	 */
    private void btnShowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnShowActionPerformed

        Calendar fromCal = Calendar.getInstance();
        Calendar toCal = Calendar.getInstance();
        if (ir.getExistedSpan(inventryTo.getDate(), fromCal, toCal)) {
            //日付の表示
            if (fromCal.equals(toCal)) {
                inventryFrom.setDate((Date) null);
                btnOutputExcel.setEnabled(false);
            } else {
                inventryFrom.setDate(fromCal.getTime());
                btnOutputExcel.setEnabled(true);
            }
            inventryTo.setDate(toCal.getTime());
        }
        
        this.searchInventry();
        this.showStatus();
        this.showInventry();
        this.showSummary();

//*****************************************************************		
/* [2009/03/05]
 * inventoryToのgetDate()メソッドで取得した日付データに
 * 時間データが含まれている場合、
 * InventoryRecordsクラスのgetDataInventory()メソッドにて、
 * compareTo()での比較が正しく処理されないため修正。

        Date date = inventryTo.getDate();
*/		
        Calendar cal = Calendar.getInstance();
        cal.setTime(inventryTo.getDate());
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        Date date = cal.getTime();
//*****************************************************************		
		
        DataInventory d = ir.getDataInventory(date);
        if (d != null) {
            
            ir.setCurrentInventry(d.getInventoryId());
            Integer id = ir.getCurrentInventry().getInventoryId();
            //選択した棚卸は編集可能か
            boolean b = ir.isEditable(id, -1);
            btnTempRegist.setEnabled(b);
            btnRegist.setEnabled(b);
            if (d.getFixed() != null && d.getFixed() == 1) {
                btnTempRegist.setEnabled(false);
            }
            
        } else {

            ir.setCurrentInventry(null);
            btnRegist.setEnabled(true);
            btnTempRegist.setEnabled(true);
        }

        // 仕入先が選択されている場合は登録ボタンを非活性にする
        if (UIUtil.getSupplierID(suppliers) != null) {
            this.btnRegist.setEnabled(false);
        }
		
    }//GEN-LAST:event_btnShowActionPerformed

	/**
	 * 棚卸期間(TO)のフォーカス取得時
	 */
    private void inventryToFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_inventryToFocusGained

        //現在設定されている日付を保存する(FocusLost時の検証用)
        if (inventryTo.isSelected()) {
            toDateTemp = inventryTo.getDate();
        } else {
            toDateTemp = null;
        }
    }//GEN-LAST:event_inventryToFocusGained

	/**
	 * 棚卸期間(TO)のフォーカス喪失時
	 */
    private void inventryToFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_inventryToFocusLost
		if (inventryFrom.getDate() == null)
		{
			return;
		}

		boolean adjust = false;
		
		if (DateRange.compareToDateOnly(inventryFrom.getDate(), inventryTo.getDate()) > 0)
		{
			//TO が FROMより前の日付に設定されたので
			//棚卸期間の切り替えを行う
			adjust = true;
		}

//        int days = DateRange.diffDays(inventryTo.getDate(), inventryFrom.getDate());
//        if (Math.abs(days) > 31) {
//            //棚卸期間が31日を超えているので
//            //棚卸期間の切り替えを行う
//            adjust = true;
//        }

		if (adjust)
		{
			//日付(TO)が変更された場合、過去の棚卸日をふまえて
			//棚卸期間を再設定する
			Calendar fromCal = Calendar.getInstance();
			Calendar toCal = Calendar.getInstance();
			if (ir.getExistedSpan(inventryTo.getDate(), fromCal, toCal))
			{
				//日付の表示
				inventryFrom.setDate(fromCal.getTime());
				inventryTo.setDate(toCal.getTime());
			}
		}
    }//GEN-LAST:event_inventryToFocusLost
	
	/**
	 * 店舗選択の変更時
	 */
    private void shopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_shopActionPerformed
		reload(true);
    }//GEN-LAST:event_shopActionPerformed
	
	/**
	 * 登録ボタン
	 */
    private void btnRegistActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRegistActionPerformed
		if (!checkInput())
		{
			return;
		}
		
		// 実在庫数入力チェック
		for (InventryData id : si) {

		    if (id.getJitsuZaiko() == null) {
			String msg = "商品の実在庫数が未入力のものがあります。\n" +
			             "実在庫数が0個の場合は、「0」を入力してください。";
			
			MessageDialog.showMessageDialog(this,
				msg,
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
			inventryTable.requestFocusInWindow();
			return;
		    }
		}
		
		//現在の棚卸はパスワードが必要か
		if (ir.getCurrentInventry() != null)
		{
                    Integer id = ir.getCurrentInventry().getInventoryId();
                    if (ir.isPasswordRequired(id, 1))
                    {
                        if (MessageDialog.showYesNoDialog(
                                    this,
                                    "過去の棚卸情報ですが、更新してよろしいですか？",
                                    this.getTitle(),
                                    JOptionPane.QUESTION_MESSAGE) == JOptionPane.NO_OPTION)
                        {
                            return;
                        }

                        // パスワードチェック
                        if (!WorkTimePasswordDialog.isAuthPassword((MstShop)shop.getSelectedItem())) {
                            return;
                        }
                    }
		}
		
		//登録処理（確定する）
		int result = this.regist(true);
		if (result > 0)
		{
			//登録しました
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(201, ""),
				this.getTitle(),
				JOptionPane.INFORMATION_MESSAGE);
			
			if (ir.getCurrentInventry() == null)
			{
				//棚卸データ（ヘッダ）を読み込む
				loadInventoryHead();
				
				//棚卸期間の初期表示を行う
				ir.setCurrentInventry(result);
				
			}
			else
			{
				//現在選択されている棚卸データを維持
				Integer id = ir.getCurrentInventry().getInventoryId();
				
				//棚卸データ（ヘッダ）を読み込む
				loadInventoryHead();
				
				ir.setCurrentInventry(id);
				
			}
			//データの再表示
			this.searchInventry();
			this.showStatus();
			this.showInventry();
			this.showSummary();

			// 更新フラグを強制的に落とす
			si.setUpdate(false);
		}
		else
		{
			//登録失敗
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(MessageUtil.ERROR_REGIST_FAILED, "棚卸"),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
			
		}
    }//GEN-LAST:event_btnRegistActionPerformed
	
	/**
	 * 仕入先コンボ変更
	 */
    private void suppliersActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_suppliersActionPerformed
		UIUtil.outputSupplier(suppliers, suppliersNo);
    }//GEN-LAST:event_suppliersActionPerformed
	
	/**
	 * 仕入先NO入力
	 */
    private void suppliersNoFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_suppliersNoFocusLost
		UIUtil.selectSupplier(suppliersNo, suppliers);
    }//GEN-LAST:event_suppliersNoFocusLost
	
	
	
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnOutputExcel;
    private javax.swing.JButton btnRegist;
    private javax.swing.JButton btnShow;
    private javax.swing.JButton btnTempRegist;
    private javax.swing.ButtonGroup conditionUnit;
    private javax.swing.JLabel dateLabel;
    private javax.swing.JLabel dispLabel;
    private jp.co.flatsoft.fscomponent.FSCalenderCombo inventryFrom;
    private javax.swing.JScrollPane inventryScrollPane;
    private com.geobeck.swing.JTableEx inventryTable;
    private jp.co.flatsoft.fscomponent.FSCalenderCombo inventryTo;
    private javax.swing.ButtonGroup inventryUnit;
    private javax.swing.ButtonGroup itemUnit;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel lblInventry;
    private javax.swing.JLabel lblTax;
    private javax.swing.JRadioButton rdoClass;
    private javax.swing.JRadioButton rdoConditionAll;
    private javax.swing.JRadioButton rdoConditionDiff;
    private javax.swing.JRadioButton rdoConditionNoDiff;
    private javax.swing.JRadioButton rdoInStock;
    private javax.swing.JRadioButton rdoInventrySale;
    private javax.swing.JRadioButton rdoInventryWork;
    private javax.swing.JRadioButton rdoOutOfStock;
    private javax.swing.JRadioButton rdoPlace;
    private javax.swing.JRadioButton rdoStockAll;
    private javax.swing.JRadioButton rdoTaxBlank;
    private javax.swing.JRadioButton rdoTaxUnit;
    private com.geobeck.sosia.pos.swing.JComboBoxLabel shop;
    private javax.swing.JLabel shopLabel;
    private javax.swing.JLabel status;
    private javax.swing.ButtonGroup stockUnit;
    private javax.swing.JScrollPane summaryScrollPane;
    private com.geobeck.swing.JTableEx summaryTable;
    private javax.swing.JComboBox suppliers;
    private javax.swing.JTextField suppliersNo;
    private javax.swing.ButtonGroup taxUnit;
    // End of variables declaration//GEN-END:variables
	
	
	/**
	 * 列の表示位置を設定するTableCellRenderer
	 */
	private class TableCellAlignRenderer extends DefaultTableCellRenderer
	{
		/** Creates a new instance of ReservationTableCellRenderer */
		public TableCellAlignRenderer()
		{
			super();
		}
		
		/**
		 * テーブルセルレンダリングを返します。
		 * @param table JTable
		 * @param value セルに割り当てる値
		 * @param isSelected セルが選択されている場合は true
		 * @param hasFocus フォーカスがある場合は true
		 * @param row 行
		 * @param column 列
		 * @return テーブルセルレンダリング
		 */
		public Component getTableCellRendererComponent(JTable table,
			Object value, boolean isSelected, boolean hasFocus, int row, int column)
		{
			super.getTableCellRendererComponent(table, value,
				isSelected, hasFocus, row, column);
			
			switch(column)
			{
				case 2:
				case 5:
				case 7:
				case 11:
				case 12:
					super.setHorizontalAlignment(SwingConstants.RIGHT);
					break;
				default:
					super.setHorizontalAlignment(SwingConstants.LEFT);
					break;
			}
			
			return this;
		}
	}
	
	/**
	 * 列の表示位置を設定するTableCellRenderer
	 */
	private class SumTableCellAlignRenderer extends DefaultTableCellRenderer
	{
		/** Creates a new instance of ReservationTableCellRenderer */
		public SumTableCellAlignRenderer()
		{
			super();
		}
		
		/**
		 * テーブルセルレンダリングを返します。
		 * @param table JTable
		 * @param value セルに割り当てる値
		 * @param isSelected セルが選択されている場合は true
		 * @param hasFocus フォーカスがある場合は true
		 * @param row 行
		 * @param column 列
		 * @return テーブルセルレンダリング
		 */
		public Component getTableCellRendererComponent(JTable table,
			Object value, boolean isSelected, boolean hasFocus, int row, int column)
		{
			super.getTableCellRendererComponent(table, value,
				isSelected, hasFocus, row, column);
			//全部右寄せ
			super.setHorizontalAlignment(SwingConstants.RIGHT);
			
			return this;
		}
	}
	
	/**
	 * 列の幅を設定する。
	 */
	private void initTableColumnWidth()
	{
		inventryTable.getColumnModel().getColumn(0).setPreferredWidth(70);
		inventryTable.getColumnModel().getColumn(1).setPreferredWidth(85);
		inventryTable.getColumnModel().getColumn(2).setPreferredWidth(60);
		inventryTable.getColumnModel().getColumn(3).setPreferredWidth(35);
		inventryTable.getColumnModel().getColumn(4).setPreferredWidth(41);
		inventryTable.getColumnModel().getColumn(5).setPreferredWidth(41);
		inventryTable.getColumnModel().getColumn(6).setPreferredWidth(60);
		inventryTable.getColumnModel().getColumn(7).setPreferredWidth(41);
		inventryTable.getColumnModel().getColumn(8).setPreferredWidth(60);
		inventryTable.getColumnModel().getColumn(9).setPreferredWidth(60);
		inventryTable.getColumnModel().getColumn(10).setPreferredWidth(60);
		inventryTable.getColumnModel().getColumn(11).setPreferredWidth(56);//////////
		inventryTable.getColumnModel().getColumn(12).setPreferredWidth(60);
		inventryTable.getColumnModel().getColumn(13).setPreferredWidth(70);
	}
	
	/**
	 * 列の幅を設定する。
	 */
	private void initSummaryTableColumnWidth()
	{
		summaryTable.getColumnModel().getColumn(0).setPreferredWidth(35);
		summaryTable.getColumnModel().getColumn(1).setPreferredWidth(41);
		summaryTable.getColumnModel().getColumn(2).setPreferredWidth(41);
		summaryTable.getColumnModel().getColumn(3).setPreferredWidth(60);
		summaryTable.getColumnModel().getColumn(4).setPreferredWidth(41);
		summaryTable.getColumnModel().getColumn(5).setPreferredWidth(60);
		summaryTable.getColumnModel().getColumn(6).setPreferredWidth(60);
		summaryTable.getColumnModel().getColumn(7).setPreferredWidth(60);
		summaryTable.getColumnModel().getColumn(8).setPreferredWidth(56);////////
		summaryTable.getColumnModel().getColumn(9).setPreferredWidth(60);
		summaryTable.getColumnModel().getColumn(10).setPreferredWidth(70);
	}
	
	
	/**
	 * ボタンにマウスカーソルが乗ったときにカーソルを変更するイベントを追加する。
	 */
	private void addMouseCursorChange()
	{
		SystemInfo.addMouseCursorChange(btnTempRegist);
		SystemInfo.addMouseCursorChange(btnRegist);
		SystemInfo.addMouseCursorChange(btnOutputExcel);
		SystemInfo.addMouseCursorChange(btnShow);
	}
	
	/**
	 * 項目移動キーの設定
	 */
	private void setKeyListener()
	{
		shop.addKeyListener(SystemInfo.getMoveNextField());
		suppliersNo.addKeyListener(SystemInfo.getMoveNextField());
		suppliersNo.addFocusListener(SystemInfo.getSelectText());
		suppliers.addKeyListener(SystemInfo.getMoveNextField());
		rdoInventrySale.addKeyListener(SystemInfo.getMoveNextField());
		rdoInventryWork.addKeyListener(SystemInfo.getMoveNextField());
		inventryFrom.addKeyListener(SystemInfo.getMoveNextField());
		inventryTo.addKeyListener(SystemInfo.getMoveNextField());
		rdoClass.addKeyListener(SystemInfo.getMoveNextField());
		rdoPlace.addKeyListener(SystemInfo.getMoveNextField());
		rdoConditionAll.addKeyListener(SystemInfo.getMoveNextField());
		rdoConditionDiff.addKeyListener(SystemInfo.getMoveNextField());
		rdoConditionNoDiff.addKeyListener(SystemInfo.getMoveNextField());
		rdoTaxUnit.addKeyListener(SystemInfo.getMoveNextField());
		rdoTaxBlank.addKeyListener(SystemInfo.getMoveNextField());
	}
	
	/**
	 * 仕入先を初期化する。
	 */
	protected void initSupplier()
	{
		suppliers.removeAllItems();
		
		MstSuppliers supplierList = new MstSuppliers();
		try
		{
			supplierList.load(SystemInfo.getConnection(), true);
			for(MstSupplier ms : supplierList)
			{
				suppliers.addItem(ms);
			}

			suppliers.setSelectedIndex(0);
		}
		catch (RuntimeException e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			throw e;
		}
		catch (Exception e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(1099),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
		}
	}

	/**
	 * 棚卸のヘッダ情報を読み込む
	 */
	private void loadInventoryHead()
	{
		loadInventoryHead(SystemInfo.getConnection());
	}

	/**
	 * 棚卸のヘッダ情報を読み込む
	 */
	private void loadInventoryHead(ConnectionWrapper con)
	{
		ir.setShop((MstShop)shop.getSelectedItem());
		
		try
		{
			ir.load(SystemInfo.getConnection());
		}
		catch (RuntimeException e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			throw e;
		}
		catch (Exception e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(1099),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
		}
	}
	
	/**
	 * 棚卸期間の表示（最新）
	 */
	public void setInventrySpan()
	{
		
		Calendar fromCal = Calendar.getInstance();
		Calendar toCal = Calendar.getInstance();

		ir.getInitialSpan(fromCal, toCal);

		if (fromCal.equals(toCal))
		{
			inventryFrom.setDate((Date) null);
		}
		inventryTo.setDate(toCal.getTime());
		
	}

	public void reload(boolean resetInventorySpan)
	{
		//既存の棚卸データ（ヘッダ）を読み込む
		ir.setShop((MstShop)shop.getSelectedItem());
		if (rdoInventrySale.isSelected())
		{
			ir.setInventoryDivision(1);
		}
		else if (rdoInventryWork.isSelected())
		{
			ir.setInventoryDivision(2);
		}

		try
		{
			ir.load(SystemInfo.getConnection());
			//棚卸期間を再設定する
			if (resetInventorySpan)
			{
				setInventrySpan();
			}
		}
		catch (RuntimeException e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			throw e;
		}
		catch (Exception e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(1099),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
		}
	}
	
	/**
	 * 棚卸保存状態を表示する。
	 */
	private void showStatus()
	{
		try
		{
		    StringBuilder sql = new StringBuilder(1000);
		    sql.append(" select");
		    sql.append("     fixed");
		    sql.append(" from");
		    sql.append("     data_inventory");
		    sql.append(" where");
		    sql.append("         delete_date is null");
		    sql.append("     and shop_id = " + SQLUtil.convertForSQL(si.getShop().getShopID()));
		    sql.append("     and inventory_division = " + SQLUtil.convertForSQL(si.getUseDivision()));
		    sql.append("     and inventory_date = " + SQLUtil.convertForSQLDateOnly(si.getToDate()));

		    ConnectionWrapper con = SystemInfo.getConnection();
		    ResultSetWrapper rs = con.executeQuery(sql.toString());

		    status.setText("【未登録】");
		    
		    while (rs.next()) {
			if (rs.getInt("fixed") == 0) {
			    status.setText("【一時保存】");
			} else {
			    status.setText("【登録済】");
			}
		    }
		    rs.close();
		    
		} catch (Exception e) {
		}
	}
	
	/**
	 * 棚卸商品の検索を行う。
	 */
	public void searchInventry()
	{
            //表示条件の設定
            this.setSearchCondition();

            if (!si.isConditionChange()) {
                //DB抽出条件に変更なし
                return;
            }
            
            try {
                ConnectionWrapper con = SystemInfo.getConnection();
                si.load(con);
            } catch (RuntimeException e) {
                SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
                throw e;
            } catch (Exception e) {
                SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
                MessageDialog.showMessageDialog(
                    this,
                    MessageUtil.getMessage(1099),
                    this.getTitle(),
                    JOptionPane.ERROR_MESSAGE);
            }
	}

	/**
	 * 検索条件をセットする。
	 */
	private void setSearchCondition()
	{
            //店舗
            si.setShop((MstShop)shop.getSelectedItem());
            //仕入先
            si.setSupplierID(UIUtil.getSupplierID(suppliers));
            //棚卸区分
            if (rdoInventrySale.isSelected()) {
                si.setUseDivision(1);
            } else if (rdoInventryWork.isSelected()) {
                si.setUseDivision(2);
            }
            //棚卸期間
            si.setFromDate(inventryFrom.getDate());
            si.setToDate(inventryTo.getDate());

            //棚卸ID
            if (ir.getCurrentInventry() != null) {
                si.setInventoryID(ir.getCurrentInventry().getInventoryId());
            } else {
                si.setInventoryID(null);
            }
            
            //TMTrong start add 20150630 New request #38257
            if(rdoStockAll.isSelected()){
                si.setInStock(0);
            }
            if(rdoInStock.isSelected()){
                si.setInStock(1);
            }
            if(rdoOutOfStock.isSelected()){
                si.setInStock(2);
            }
           //TMTrong end add 20150630 New request #38257
	}

	/**
	 * 棚卸検索結果を表示する。
	 */
	public void showInventry()
	{
            SwingUtil.clearTable(inventryTable);

            if (si.isEmpty()) {
                //データなし
                MessageDialog.showMessageDialog(this,
                        MessageUtil.getMessage(1112, ""),
                        this.getTitle(),
                        JOptionPane.ERROR_MESSAGE);
                return;
            }

            //分類／置場でソート
            if (rdoClass.isSelected()) {
                si.sortByClass();
            }
            if (rdoPlace.isSelected()) {
                si.sortByPlace();
            }

            DefaultTableModel model = (DefaultTableModel)inventryTable.getModel();

            for(InventryData id : si)
            {
                boolean display = true;
                Integer kisyu = id.getKisyuNum();
                Integer nyuko = id.getNyukoNum();
                Integer attach = id.getNyukoAttachNum();
                Integer syuko = id.getSyukoNum();
                Integer tyoboZaiko = kisyu + nyuko + attach - syuko;
                Integer jitsuZaiko = id.getJitsuZaiko();
                Integer kahusoku = (jitsuZaiko == null ? -tyoboZaiko : jitsuZaiko - tyoboZaiko);

                //過不足ありを表示
                if (rdoConditionDiff.isSelected()) {
                    if (kahusoku != null && kahusoku == 0) {
                        //表示しない
                        display = false;
                    }
                    if (id.isJitsuZaikoNull()) {
                        //実在庫が未入力なら必ず表示
                        display = true;
                    }
                }

                //過不足なしを表示
                if (rdoConditionNoDiff.isSelected()) {
                    if (kahusoku != null && kahusoku != 0) {
                        //表示しない
                        display = false;
                    }
                }

                //仕入価格
                Long costPrice = 0l;
                Long nyukoCostPrice = 0l;
                Long syukoCostPrice = 0l;
                
                if (rdoTaxUnit.isSelected()) {
                    //税込額
                    costPrice = id.getCostPriceTaxIn();
                    nyukoCostPrice = id.getNyukoCostPriceTaxIn();
                    syukoCostPrice = id.getSyukoCostPriceTaxIn();
                }
                if (rdoTaxBlank.isSelected()) {
                    //税抜額
                    costPrice = id.getCostPriceTaxEx();
                    nyukoCostPrice = id.getNyukoCostPriceTaxEx();
                    syukoCostPrice = id.getSyukoCostPriceTaxEx();
                }
                
                if (display) {

                    ArrayList<Object> rowData = new ArrayList<Object>();

                    //分類／置場
                    if (rdoClass.isSelected()) {
                        rowData.add(id.getItemClassName());
                    } if (rdoPlace.isSelected()) {
                        rowData.add(id.getPlaceName());
                    }
                    //商品名
                    MstItem item = new MstItem();
                    item.setItemID(id.getItemID());
                    item.setItemName(id.getItemName());
                    rowData.add(item);
                    //仕入価格
                    rowData.add(costPrice);
                    //期首
                    rowData.add(kisyu);
                    //入庫数
                    rowData.add(nyuko);
                    //添付数
                    rowData.add(attach);
                    //入庫金額
                    rowData.add(nyuko * nyukoCostPrice);
                    //出庫数
                    rowData.add(syuko);
                    //出庫金額
                    rowData.add(syuko * syukoCostPrice);
                    //帳簿在庫
                    rowData.add(tyoboZaiko);
                    //実在庫数
                    rowData.add(jitsuZaiko);
                    //過不足数
                    rowData.add(kahusoku);
                    //在庫金額
                    if (id.isJitsuZaikoNull()) {
                        rowData.add(null);
                    } else {
                        rowData.add(jitsuZaiko * costPrice);
                    }
                    //過不足金額
                    if (kahusoku == null) {
                        rowData.add(null);
                    } else {
                        rowData.add(kahusoku * costPrice);
                    }

                    model.addRow(rowData.toArray());
                }
            }

            //選択された棚卸が確定済みの場合は一時保存を無効とする
            this.btnTempRegist.setEnabled(true);
            if (ir.getCurrentInventry() != null) {
                if (ir.getCurrentInventry().getFixed() == 1) {
                    this.btnTempRegist.setEnabled(false);
                }
            }
	}

	/**
	 * 棚卸合計を表示する。
	 */
	public void showSummary()
	{
		SwingUtil.clearTable(summaryTable);
		
		DefaultTableModel model = (DefaultTableModel)summaryTable.getModel();
		
		Integer kisyuSum = 0;
		Integer nyukoSum = 0;
		Integer attachSum = 0;
		Integer syukoSum = 0;
		Integer tyoboZaikoSum = 0;
		Integer jitsuZaikoSum = 0;
		Integer kahusokuSum = 0;
		
		Long nyukoKinSum = 0l;
		Long syukoKinSum = 0l;
		Long zaikoKinSum = 0l;
		Long kahusokuKinSum = 0l;
		
		for(InventryData id : si)
		{
			Integer kisyu = id.getKisyuNum();
			Integer nyuko = id.getNyukoNum();
			Integer attach = id.getNyukoAttachNum();
			Integer syuko = id.getSyukoNum();
			Integer tyoboZaiko = kisyu + nyuko + attach - syuko;
			Integer jitsuZaiko = id.getJitsuZaiko();
			Integer kahusoku = (jitsuZaiko == null ? -tyoboZaiko : jitsuZaiko - tyoboZaiko);
			
			//仕入価格
			Long costPrice = 0l;
                        Long nyukoCostPrice = 0l;
                        Long syukoCostPrice = 0l;

			if (rdoTaxUnit.isSelected()) {
                            //税込額
                            costPrice = id.getCostPriceTaxIn();
                            nyukoCostPrice = id.getNyukoCostPriceTaxIn();
                            syukoCostPrice = id.getSyukoCostPriceTaxIn();
			}

			if (rdoTaxBlank.isSelected()) {
                            //税抜額
                            costPrice = id.getCostPriceTaxEx();
                            nyukoCostPrice = id.getNyukoCostPriceTaxEx();
                            syukoCostPrice = id.getSyukoCostPriceTaxEx();
			}

			kisyuSum += kisyu;
			nyukoSum += nyuko;
			attachSum += attach;
			syukoSum += syuko;
			tyoboZaikoSum += tyoboZaiko;
			jitsuZaikoSum += (jitsuZaiko == null ? 0 : jitsuZaiko);
			kahusokuSum += kahusoku;
			
			nyukoKinSum += (nyuko * nyukoCostPrice);
			syukoKinSum += (syuko * syukoCostPrice);
			zaikoKinSum += ((jitsuZaiko == null ? 0 : jitsuZaiko) * costPrice);
			kahusokuKinSum += (kahusoku * costPrice);
		}
		
		ArrayList<Object> rowData = new ArrayList<Object>();
		
		//期首
		rowData.add(kisyuSum);
		//入庫数
		rowData.add(nyukoSum);
		//添付数
		rowData.add(attachSum);
		//入庫金額
		rowData.add(nyukoKinSum);
		//出庫数
		rowData.add(syukoSum);
		//出庫金額
		rowData.add(syukoKinSum);
		//帳簿在庫
		rowData.add(tyoboZaikoSum);
		//実在庫数
		rowData.add(jitsuZaikoSum);
		//過不足数
		rowData.add(kahusokuSum);
		//在庫金額
		rowData.add(zaikoKinSum);
		//過不足金額
		rowData.add(kahusokuKinSum);
		
		model.addRow(rowData.toArray());
	}
	
	/**
	 * 実在庫数変更時に呼ばれる
	 */
	private void changeInventry()
	{
		int row = inventryTable.getEditingRow();
		int col = inventryTable.getEditingColumn();
		
		if(row < 0 || col < 0)	return;
		
		Integer jitsuZaiko = (Integer) inventryTable.getValueAt(row, col);
		MstItem item = (MstItem) inventryTable.getValueAt(row, 1);
		
		int listIndex = si.indexOfItem(item.getItemID());
		
		InventryData id = si.get(listIndex);

		//実在庫数を反映
		id.setJitsuZaiko(jitsuZaiko);

		//過不足数を変更
		Integer kisyu = id.getKisyuNum();
		Integer nyuko = id.getNyukoNum();
		Integer attach = id.getNyukoAttachNum();
		Integer syuko = id.getSyukoNum();
		Integer tyoboZaiko = kisyu + nyuko + attach - syuko;
		Integer kahusoku = jitsuZaiko - tyoboZaiko;
		
		inventryTable.setValueAt(kahusoku, row, 11);
		
		//仕入単価を求める
		Long costPrice = 0l;
		if (rdoTaxUnit.isSelected())
		{
			//税込額
			costPrice = id.getCostPriceTaxIn();
		}
		if (rdoTaxBlank.isSelected())
		{
			//税抜額
			costPrice = id.getCostPriceTaxEx();
		}
		
		//在庫金額を変更
		inventryTable.setValueAt(costPrice * jitsuZaiko, row, 12);
		//過不足金額を変更
		inventryTable.setValueAt(costPrice * kahusoku, row, 13);
		
		//合計欄の更新
		showSummary();
	}
	
	private boolean checkInput()
	{
		// 棚卸期間のチェック
		if (inventryTo.getDate() == null)
		{
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(MessageUtil.ERROR_INPUT_EMPTY, "棚卸期間"),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
			inventryTo.requestFocusInWindow();
			return false;
		}
		
		// 棚卸日数のチェック
		if ((DateRange.diffDays(inventryFrom.getDate(), inventryTo.getDate()) + 1) >= 32)
		{
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(12002),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
			inventryTo.requestFocusInWindow();
			return false;
		}
	
		return true;
	}
	
	/**
	 * 登録処理を行う。
	 * @return 棚卸ID。エラー時は-1
	 */
	public int regist(boolean fixed)
	{
		int			result	= -1;
		boolean     ret;
		Integer      fixedValue = null;
		
		try
		{
			if (si.isEmpty())
			{
				return -1;
			}
			
			if (fixed)
			{
				fixedValue = 1;
			}
			else
			{
				fixedValue = 0;
			}
			
			ConnectionWrapper	con	=	SystemInfo.getConnection();
			//トランザクション開始
			con.begin();
			
			try
			{
				DataInventory di = null;
				if (ir.getCurrentInventry() != null)
				{
					di = ir.getCurrentInventry();
					//棚卸終了日
					di.setInventoryDate(inventryTo.getDate());
				}
				else
				{
					//新規作成
					di = new DataInventory();
					
					di.setShopId(si.getShop().getShopID());
					//棚卸終了日
					di.setInventoryDate(inventryTo.getDate());

					//棚卸IDの採番
					di.setNewInventoryID(con);
					
					if (rdoInventrySale.isSelected())
					{
						di.setInventoryDivision(1);
					}
					else if (rdoInventryWork.isSelected())
					{
						di.setInventoryDivision(2);
					}
				}

				//確定フラグをセット
				di.setFixed(fixedValue);
				
				result = di.getInventoryId();
				//棚卸データの登録
				if (di.isExists(con))
				{
					ret = di.update(con);
				}
				else
				{
					ret = di.insert(con);
				}
				
				if (ret)
				{
					// 棚卸詳細データ全件削除（登録ボタン押下時のみ）
                                        // 一時保存の場合は仕入先で絞り込まれている可能性があるため全件削除しない
                                        if (fixed) {
                                            DataInventoryDetail.physicalDelete(con, di.getInventoryId(), si.getUseDivision());
                                        }
                                    
					//棚卸詳細データの登録
					for (InventryData id : si)
					{
						DataInventoryDetail dd = new DataInventoryDetail();

						dd.setInventoryID(di.getInventoryId());
						dd.setItemID(id.getItemID());
						dd.setInventoryDivision(si.getUseDivision());
						dd.setInitialStock(id.getKisyuNum());
						dd.setRealStock(id.getJitsuZaiko());
						dd.setCostPrice(id.getCostPriceTaxIn());

                                                if (fixed) {
                                                    ret = dd.insert(con);
                                                } else {
                                                    if (dd.isExists(con)) {
                                                        ret = dd.update(con);
                                                    } else {
                                                        ret = dd.insert(con);
                                                    }
                                                }
                                                
						if (!ret) {
                                                    result = -1;
                                                    break;
						}
					}
				}
				else
				{
					result = -1;
				}
			}
			catch(Exception e)
			{
				SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
				con.rollback();
				result = -1;

				throw e;
			}
			
			if (result > 0)
			{
				con.commit();
			}
			else
			{
				con.rollback();
			}
		}
		catch (RuntimeException e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			throw e;
		}
		catch(Exception e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
			MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(1099),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
		}
		
		return	result;
	}
        
        //IVS_LVTu start add 2015/07/22 New request #40693
        public void getDataInventry()
	{
            Calendar fromCal = Calendar.getInstance();
            Calendar toCal = Calendar.getInstance();
            if (ir.getExistedSpan(inventryTo.getDate(), fromCal, toCal)) {
                //日付の表示
                if (fromCal.equals(toCal)) {
                    inventryFrom.setDate((Date) null);
                    btnOutputExcel.setEnabled(false);
                } else {
                    inventryFrom.setDate(fromCal.getTime());
                    btnOutputExcel.setEnabled(true);
                }
                inventryTo.setDate(toCal.getTime());
            }

            this.searchInventry();
            ArrayList<PrintInventoryProductBean>  prodlist = new ArrayList<PrintInventoryProductBean>();
            PrintInventoryProductBean prodbean = null;

            //分類／置場でソート
            if (rdoClass.isSelected()) {
                si.sortByClass();
            }
            if (rdoPlace.isSelected()) {
                si.sortByPlace();
            }


            for(InventryData id : si)
            {
                prodbean = new PrintInventoryProductBean();
                boolean display = true;
                Integer kisyu = id.getKisyuNum()!= null ? id.getKisyuNum() : 0 ;
                Integer nyuko = id.getNyukoNum()!= null ? id.getNyukoNum() : 0 ;
                Integer attach = id.getNyukoAttachNum()!= null ? id.getNyukoAttachNum() : 0;
                Integer syuko = id.getSyukoNum()!= null ? id.getSyukoNum() : 0;
                Integer tyoboZaiko = kisyu + nyuko + attach - syuko;
                Integer jitsuZaiko = id.getJitsuZaiko()!= null ? id.getJitsuZaiko() : 0;
                Integer kahusoku = (jitsuZaiko == null ? -tyoboZaiko : jitsuZaiko - tyoboZaiko);

                //過不足ありを表示
                if (rdoConditionDiff.isSelected()) {
                    if (kahusoku != null && kahusoku == 0) {
                        //表示しない
                        display = false;
                    }
                    if (id.isJitsuZaikoNull()) {
                        //実在庫が未入力なら必ず表示
                        display = true;
                    }
                }

                //過不足なしを表示
                if (rdoConditionNoDiff.isSelected()) {
                    if (kahusoku != null && kahusoku != 0) {
                        //表示しない
                        display = false;
                    }
                }

                //仕入価格
                Long costPrice = 0l;
                Long nyukoCostPrice = 0l;
                Long syukoCostPrice = 0l;
                
                if (rdoTaxUnit.isSelected()) {
                    //税込額
                    costPrice = id.getCostPriceTaxIn();
                    nyukoCostPrice = id.getNyukoCostPriceTaxIn();
                    syukoCostPrice = id.getSyukoCostPriceTaxIn();
                }
                if (rdoTaxBlank.isSelected()) {
                    //税抜額
                    costPrice = id.getCostPriceTaxEx();
                    nyukoCostPrice = id.getNyukoCostPriceTaxEx();
                    syukoCostPrice = id.getSyukoCostPriceTaxEx();
                }
                
                if (display) {

                    //ArrayList<Object> rowData = new ArrayList<Object>();

                    //分類／置場
                    prodbean.setClassId(id.getItemClassID());
                    prodbean.setCategory(id.getItemClassName());
                    
                    //商品名
                    prodbean.setId(id.getItemID());
                    prodbean.setStockName(id.getItemName());
                    //仕入価格
                    prodbean.setRawProductEst(costPrice);
                    //期首
                    prodbean.setTermProd(kisyu);
                    //入庫数
                    prodbean.setStoreInCnt(nyuko);
                    //添付数
                    prodbean.setStoreAttachCnt(attach);
                    //入庫金額
                    prodbean.setStoreInAmnt(nyuko * nyukoCostPrice);
                    //出庫数
                    prodbean.setStoreOutCnt(syuko);
                    //出庫金額
                    prodbean.setStoreOutAmnt(syuko * syukoCostPrice);
                    //帳簿在庫
                    //rowData.add(tyoboZaiko);
                    prodbean.setAccount(tyoboZaiko);
                    //実在庫数
                    prodbean.setActualCnt(jitsuZaiko);
                    //過不足数
                    
                    //在庫金額
                    if (id.isJitsuZaikoNull()) {
                        prodbean.setTotalAmnt(0l);
                    } else {
                        prodbean.setTotalAmnt(jitsuZaiko * costPrice);
                    }
                    //過不足金額
                    if (kahusoku == null) {
                        //rowData.add(null);
                        prodbean.setExcessAmnt(0l);
                    } else {
                        prodbean.setExcessAmnt(kahusoku * costPrice);
                    }
                    prodlist.add(prodbean);
                } 
            }
            inventoryLogic.setInventoryProductBean(prodlist);
	}
        //IVS_LVTu end add 2015/07/22 New request #40693

	private class FocusTraversalPolicyImpl extends FocusTraversalPolicy
	{
		/**
		 * aComponent のあとでフォーカスを受け取る Component を返します。
		 * aContainer は aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダでなければなりません。
		 * @param aContainer aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @param aComponent aContainer のおそらく間接的な子、または aContainer 自体
		 * @return aComponent のあとにフォーカスを受け取る Component。適切な Component が見つからない場合は null
		 */
		public Component getComponentAfter(Container aContainer, Component aComponent)
		{
			if (aComponent.equals(shop))
			{
				return suppliersNo;
			}
			else if (aComponent.equals(suppliersNo))
			{
				return suppliers;
			}
			else if (  aComponent.equals(rdoInventrySale) || aComponent.equals(rdoInventryWork))
			{
				 if(inventryFrom.isEditable()){
                                     return inventryFrom;
                                 }
                                 return inventryTo;
			}
			else if (aComponent.equals(inventryFrom))
			{
				return inventryTo;
			}
			else if (aComponent.equals(inventryTo))
			{
				if(rdoClass.isSelected()){
                                    return rdoClass;
                                }return rdoPlace;
			}
			else if (aComponent.equals(rdoClass) ||aComponent.equals(rdoPlace) )
			{
                            if(rdoConditionAll.isSelected()){
                                return rdoConditionAll;
                            }else if (rdoConditionDiff.isSelected()){
                                return rdoConditionDiff;
                            } return rdoConditionNoDiff;
			}
			else if (aComponent.equals(rdoConditionAll)||
                                aComponent.equals(rdoConditionDiff)||
                                aComponent.equals(rdoConditionNoDiff))
			{
				if(rdoTaxUnit.isSelected()){
                                    return rdoTaxUnit;
                                } return rdoTaxBlank;
			}
			

			return this.getStartComponent();
		}

		/**
		 * aComponent の前にフォーカスを受け取る Component を返します。
		 * aContainer は aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダでなければなりません。
		 * @param aContainer aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @param aComponent aContainer のおそらく間接的な子、または aContainer 自体
		 * @return aComponent の前にフォーカスを受け取る Component。適切な Component が見つからない場合は null
		 */
		public Component getComponentBefore(Container aContainer, Component aComponent)
		{
			if (aComponent.equals(rdoTaxBlank))
			{
				return rdoTaxUnit;
			}
			else if (aComponent.equals(rdoTaxUnit))
			{
				return rdoConditionNoDiff;
			}
			else if (aComponent.equals(rdoConditionNoDiff))
			{
				return rdoConditionDiff;
			}
			else if (aComponent.equals(rdoConditionDiff))
			{
				return rdoConditionAll;
			}
			else if (aComponent.equals(rdoConditionAll))
			{
				return rdoPlace;
			}
			else if (aComponent.equals(rdoPlace))
			{
				return rdoClass;
			}
			else if (aComponent.equals(rdoClass))
			{
				return inventryTo;
			}
			else if (aComponent.equals(inventryTo))
			{
				return inventryFrom;
			}
			else if (aComponent.equals(inventryFrom))
			{
				return rdoInventryWork;
			}
			else if (aComponent.equals(rdoInventryWork))
			{
				return rdoInventrySale;
			}
			else if (aComponent.equals(rdoInventrySale))
			{
				return suppliers;
			}
			else if (aComponent.equals(suppliers))
			{
				return suppliersNo;
			}
			else if (aComponent.equals(suppliersNo))
			{
				return shop;
			}
			else if (aComponent.equals(shop))
			{
				return shop;
			}
			
			return this.getStartComponent();
		}
		
		/**
		 * トラバーサルサイクルの最初の Component を返します。
		 * このメソッドは、順方向のトラバーサルがラップするときに、次にフォーカスする Component を判定するために使用します。
		 * @param aContainer 先頭の Component を返すフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @return aContainer のトラバーサルサイクルの先頭の Componet、または適切な Component が見つからない場合は null
		 */
		public Component getFirstComponent(Container aContainer)
		{
			return this.getStartComponent();
		}
		
		/**
		 * トラバーサルサイクルの最後の Component を返します。
		 * このメソッドは、逆方向のトラバーサルがラップするときに、次にフォーカスする Component を判定するために使用します。
		 * @param aContainer aContainer - 最後の Component を返すフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @return aContainer のトラバーサルサイクルの最後の Componet、または適切な Component が見つからない場合は null
		 */
		public Component getLastComponent(Container aContainer)
		{
			return rdoTaxBlank;
		}
		
		/**
		 * フォーカスを設定するデフォルトコンポーネントを返します。
		 * aContainer をルートとするフォーカストラバーサルサイクルが新しく開始されたときに、このコンポーネントに最初にフォーカスが設定されます。
		 * @param aContainer デフォルトの Component を返すフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @return aContainer のトラバーサルサイクルのデフォルトの Componet、または適切な Component が見つからない場合は null
		 */
		public Component getDefaultComponent(Container aContainer)
		{
			return this.getStartComponent();
		}
		
		/**
		 * ウィンドウが最初に表示されたときにフォーカスが設定されるコンポーネントを返します。
		 * show() または setVisible(true) の呼び出しで一度ウィンドウが表示されると、
		 * 初期化コンポーネントはそれ以降使用されません。
		 * 一度別のウィンドウに移ったフォーカスが再び設定された場合、
		 * または、一度非表示状態になったウィンドウが再び表示された場合は、
		 * そのウィンドウの最後にフォーカスが設定されたコンポーネントがフォーカス所有者になります。
		 * このメソッドのデフォルト実装ではデフォルトコンポーネントを返します。
		 * @param window 初期コンポーネントが返されるウィンドウ
		 * @return 最初にウィンドウが表示されるときにフォーカス設定されるコンポーネント。適切なコンポーネントがない場合は null
		 */
		public Component getInitialComponent(Window window)
		{
			return this.getStartComponent();
		}
                public Component getStartComponent()
		{
			if(shop.getItemCount() ==1)
                        {
                            return suppliersNo;
                        }
                        return shop;
		}
	}
}
