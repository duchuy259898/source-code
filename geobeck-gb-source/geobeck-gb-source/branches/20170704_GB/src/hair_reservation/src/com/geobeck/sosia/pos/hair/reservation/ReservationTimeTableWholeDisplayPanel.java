/*
 * ReservationTimeTableWholeDisplayPanel.java
 *
 * Created on 2008/08/10, 10:00
 */

package com.geobeck.sosia.pos.hair.reservation;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.logging.*;
import java.sql.*;
import javax.swing.*;
import javax.swing.table.*;
import com.geobeck.sql.*;
import com.geobeck.swing.*;
import com.geobeck.util.*;
import com.geobeck.sosia.pos.master.company.*;
import com.geobeck.sosia.pos.system.*;
import java.awt.print.PageFormat;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import javax.print.attribute.HashPrintRequestAttributeSet;
import javax.print.attribute.PrintRequestAttributeSet;
import javax.print.attribute.standard.MediaSizeName;
import javax.print.attribute.standard.OrientationRequested;

/**
 *
 * @author  saito
 */
public class ReservationTimeTableWholeDisplayPanel extends com.geobeck.sosia.pos.swing.AbstractImagePanelEx implements Printable {
	
	private final Integer	HEADER_WIDTH	=	118;                            /** ヘッダの幅  */	
	private	final Integer	ROW_HEIGHT	=	SystemInfo.TABLE_ROW_HEIGHT;    /** 行の高さ */
	private	final Integer	COLUMN_WIDTH	=	30;                             /** 列の幅 */
	
	private final Color	COLOR_HEADER		=	new Color(0xffffff);    /** ヘッダの色  */
	private final Color	COLOR_RESERVATION	=	new Color(0xffff00);    /** 予約の色 */
	private final Color	COLOR_STAY		=	new Color(0xccff66);    /** 在店の色 */
	private final Color	COLOR_FINISH		=	new Color(0xc4e1ff);    /** 退店の色 */
	private final Color	COLOR_MOBILE		=	new Color(0xff9999);    /** モバイル予約の色 */

        private final double   SCALE                   =       0.5;                     /** ハードコピーの倍率 */

        private Integer	term		=	30;                                                 /** 時間単位(30分) */
	private	Integer	openHour	=	SystemInfo.getCurrentShop().getOpenHour();      /** 開店時 */
	private	Integer	openMinute	=	SystemInfo.getCurrentShop().getOpenMinute();    /** 開店分 */
//	private	Integer	closeHour	=	openHour + 14;                                      /** 閉店時(開店から14時間) */
	private	Integer	closeHour	;                                      /** 閉店時(開店から14時間) */
	private	Integer	closeMinute	=	openMinute;                                         /** 閉店分(開店から14時間) */
	
	private	GregorianCalendar	currentDate	=	new GregorianCalendar();        /** 日付 */
	
	private	TimeSchedule	ts		=	new TimeSchedule();                     /** タイムスケジュール画面用処理クラス */
        
	/** Creates new form ReservationTimeTableWholeDisplayPanel */
        public ReservationTimeTableWholeDisplayPanel(java.util.Date date)
	{
	    this(date, SystemInfo.getCurrentShop());
	}
	
	public ReservationTimeTableWholeDisplayPanel(java.util.Date date, MstShop ms)
	{
                super();
		initComponents();
		this.setSize(1016, 676);
		this.setPath("予約管理");
		this.setTitle("予約一覧");
		addMouseCursorChange();
                this.date.setDate(date);
		ts.setShop(ms);
		this.load();
                
                // 施術台の使用有無で要らないやつを消す
                MstShop mShop = ts.getShop();
//                if(mShop != null && !mShop.isBed())
                {
                    bedPanel.setVisible(false);
                    System.out.println(staffPanel.getPreferredSize().getHeight());
                    staffPanel.setPreferredSize(new Dimension((int)(staffPanel.getPreferredSize().getWidth()), (int)(staffPanel.getPreferredSize().getHeight() + bedPanel.getPreferredSize().getHeight())));
                    staffScrollPane.setPreferredSize(new Dimension((int)(staffScrollPane.getPreferredSize().getWidth()), (int)(staffScrollPane.getPreferredSize().getHeight() + bedPanel.getPreferredSize().getHeight())));
                    staffNameScrollPane.setPreferredSize(new Dimension((int)(staffNameScrollPane.getPreferredSize().getWidth()), (int)(staffNameScrollPane.getPreferredSize().getHeight() + bedPanel.getPreferredSize().getHeight())));
                    
                    System.out.println(staffPanel.getPreferredSize().getHeight());
                }
                
	}
	
	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel = new javax.swing.JPanel();
        title = new com.geobeck.swing.ImageLabel();
        jLabel1 = new javax.swing.JLabel();
        date = new jp.co.flatsoft.fscomponent.FSCalenderCombo();
        infoPanel = new javax.swing.JPanel();
        reserveColorLabel = new javax.swing.JLabel();
        reserveLabel = new javax.swing.JLabel();
        stayColorLabel = new javax.swing.JLabel();
        stayLabel = new javax.swing.JLabel();
        finishColorLabel = new javax.swing.JLabel();
        finishLabel = new javax.swing.JLabel();
        mobileColorLabel = new javax.swing.JLabel();
        mobileLabel = new javax.swing.JLabel();
        printButton = new javax.swing.JButton();
        closeButton = new javax.swing.JButton();
        staffPanel = new javax.swing.JPanel();
        staffScrollPane = new javax.swing.JScrollPane();
        staffTable = new com.geobeck.swing.JTableEx();
        staffNameScrollPane = new javax.swing.JScrollPane();
        staffNameTable = new javax.swing.JTable();
        bedPanel = new javax.swing.JPanel();
        bedScrollPane = new javax.swing.JScrollPane();
        bedTable = new com.geobeck.swing.JTableEx();
        bedNameScrollPane = new javax.swing.JScrollPane();
        bedNameTable = new javax.swing.JTable();

        jPanel.setOpaque(false);
        jPanel.setLayout(null);

        title.setImage(new javax.swing.ImageIcon(getClass().getResource("/images/" + SystemInfo.getSkinPackage() + "/menu/title/title_f_re.jpg")));
        jPanel.add(title);
        title.setBounds(0, 0, 420, 30);

        jLabel1.setText("予約日");
        jPanel.add(jLabel1);
        jLabel1.setBounds(420, 5, 36, 20);

        date.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        date.setDate(date.getDate() == null ? new java.util.Date() : date.getDate());
        date.setEditable(false);
        jPanel.add(date);
        date.setBounds(460, 5, 88, 20);

        infoPanel.setOpaque(false);

        reserveColorLabel.setBackground(this.COLOR_RESERVATION);
        reserveColorLabel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        reserveColorLabel.setOpaque(true);

        reserveLabel.setText("予約");

        stayColorLabel.setBackground(this.COLOR_STAY);
        stayColorLabel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        stayColorLabel.setOpaque(true);

        stayLabel.setText("在店");

        finishColorLabel.setBackground(this.COLOR_FINISH);
        finishColorLabel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        finishColorLabel.setOpaque(true);

        finishLabel.setText("退店");

        mobileColorLabel.setBackground(this.COLOR_MOBILE);
        mobileColorLabel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        mobileColorLabel.setOpaque(true);

        mobileLabel.setText("WEB予約");

        javax.swing.GroupLayout infoPanelLayout = new javax.swing.GroupLayout(infoPanel);
        infoPanel.setLayout(infoPanelLayout);
        infoPanelLayout.setHorizontalGroup(
            infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(infoPanelLayout.createSequentialGroup()
                .addComponent(reserveColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(reserveLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stayColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stayLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(finishColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(finishLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mobileColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mobileLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        infoPanelLayout.setVerticalGroup(
            infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(infoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(stayLabel)
                    .addComponent(finishLabel)
                    .addComponent(finishColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(mobileLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 13, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(mobileColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(reserveLabel)
                            .addGroup(infoPanelLayout.createSequentialGroup()
                                .addGap(1, 1, 1)
                                .addComponent(reserveColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addComponent(stayColorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 12, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel.add(infoPanel);
        infoPanel.setBounds(555, 0, 230, 30);

        printButton.setIcon(SystemInfo.getImageIcon("/button/common/print_off.jpg"));
        printButton.setBorderPainted(false);
        printButton.setContentAreaFilled(false);
        printButton.setPressedIcon(SystemInfo.getImageIcon("/button/common/print_on.jpg"));
        printButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                printButtonActionPerformed(evt);
            }
        });
        jPanel.add(printButton);
        printButton.setBounds(795, 0, 92, 25);

        closeButton.setIcon(SystemInfo.getImageIcon("/button/common/close_off.jpg"));
        closeButton.setBorderPainted(false);
        closeButton.setContentAreaFilled(false);
        closeButton.setPressedIcon(SystemInfo.getImageIcon("/button/common/close_on.jpg"));
        closeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButtonActionPerformed(evt);
            }
        });
        jPanel.add(closeButton);
        closeButton.setBounds(895, 0, 92, 25);

        staffPanel.setOpaque(false);

        staffScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        staffScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        staffScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        staffScrollPane.getVerticalScrollBar().addAdjustmentListener(
            new AdjustmentListener()
            {
                public void adjustmentValueChanged(AdjustmentEvent e)
                {
                    staffNameScrollPane.getVerticalScrollBar().setValue(e.getValue());
                }
            });

            staffScrollPane.getHorizontalScrollBar().addAdjustmentListener(
                new AdjustmentListener()
                {
                    public void adjustmentValueChanged(AdjustmentEvent e)
                    {
                        staffNameScrollPane.getHorizontalScrollBar().setValue(e.getValue());
                    }
                });

                staffTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
                staffTable.setRowSelectionAllowed(false);
                staffTable.setSelectionBackground(new java.awt.Color(220, 220, 220));
                staffTable.setSelectionForeground(new java.awt.Color(0, 0, 0));
                //this.initTable(staffTable);
                staffScrollPane.setViewportView(staffTable);

                staffNameScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
                staffNameScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
                staffNameScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

                staffNameTable.setModel(new javax.swing.table.DefaultTableModel(
                    new Object [][] {

                    },
                    new String [] {
                        "スタッフ名"
                    }
                ) {
                    Class[] types = new Class [] {
                        java.lang.String.class
                    };
                    boolean[] canEdit = new boolean [] {
                        false
                    };

                    public Class getColumnClass(int columnIndex) {
                        return types [columnIndex];
                    }

                    public boolean isCellEditable(int rowIndex, int columnIndex) {
                        return canEdit [columnIndex];
                    }
                });
                staffNameTable.setRequestFocusEnabled(false);
                staffNameTable.setRowSelectionAllowed(false);
                staffNameTable.setSelectionBackground(new java.awt.Color(220, 220, 220));
                staffNameTable.setSelectionForeground(new java.awt.Color(0, 0, 0));
                staffNameTable.getTableHeader().setReorderingAllowed(false);
                staffNameTable.getTableHeader().setSize(staffNameTable.getTableHeader().getWidth(), ROW_HEIGHT);
                staffNameTable.setRowHeight(ROW_HEIGHT);
                SwingUtil.setJTableHeaderRenderer(staffNameTable, SystemInfo.getTableHeaderRenderer());
                staffNameScrollPane.setViewportView(staffNameTable);

                javax.swing.GroupLayout staffPanelLayout = new javax.swing.GroupLayout(staffPanel);
                staffPanel.setLayout(staffPanelLayout);
                staffPanelLayout.setHorizontalGroup(
                    staffPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(staffPanelLayout.createSequentialGroup()
                        .addComponent(staffNameScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(staffScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 873, Short.MAX_VALUE))
                );
                staffPanelLayout.setVerticalGroup(
                    staffPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(staffNameScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 320, Short.MAX_VALUE)
                    .addComponent(staffScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 320, Short.MAX_VALUE)
                );

                bedPanel.setOpaque(false);

                bedScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
                bedScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
                bedScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
                bedScrollPane.getVerticalScrollBar().addAdjustmentListener(
                    new AdjustmentListener()
                    {
                        public void adjustmentValueChanged(AdjustmentEvent e)
                        {
                            bedNameScrollPane.getVerticalScrollBar().setValue(e.getValue());
                        }
                    });

                    bedTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
                    bedTable.setRowSelectionAllowed(false);
                    bedTable.setSelectionBackground(new java.awt.Color(220, 220, 220));
                    bedTable.setSelectionForeground(new java.awt.Color(0, 0, 0));
                    //this.initTable(bedTable);
                    bedScrollPane.setViewportView(bedTable);

                    bedNameScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
                    bedNameScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
                    bedNameScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

                    bedNameTable.setModel(new javax.swing.table.DefaultTableModel(
                        new Object [][] {

                        },
                        new String [] {
                            "施術台名"
                        }
                    ) {
                        Class[] types = new Class [] {
                            java.lang.String.class
                        };
                        boolean[] canEdit = new boolean [] {
                            false
                        };

                        public Class getColumnClass(int columnIndex) {
                            return types [columnIndex];
                        }

                        public boolean isCellEditable(int rowIndex, int columnIndex) {
                            return canEdit [columnIndex];
                        }
                    });
                    bedNameTable.setRequestFocusEnabled(false);
                    bedNameTable.setRowSelectionAllowed(false);
                    bedNameTable.setSelectionBackground(new java.awt.Color(220, 220, 220));
                    bedNameTable.setSelectionForeground(new java.awt.Color(0, 0, 0));
                    bedNameTable.getTableHeader().setReorderingAllowed(false);
                    bedNameTable.getTableHeader().setSize(bedNameTable.getTableHeader().getWidth(), ROW_HEIGHT);
                    bedNameTable.setRowHeight(ROW_HEIGHT);
                    SwingUtil.setJTableHeaderRenderer(bedNameTable, SystemInfo.getTableHeaderRenderer());
                    bedNameScrollPane.setViewportView(bedNameTable);

                    javax.swing.GroupLayout bedPanelLayout = new javax.swing.GroupLayout(bedPanel);
                    bedPanel.setLayout(bedPanelLayout);
                    bedPanelLayout.setHorizontalGroup(
                        bedPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(bedPanelLayout.createSequentialGroup()
                            .addComponent(bedNameScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(bedScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 873, Short.MAX_VALUE))
                    );
                    bedPanelLayout.setVerticalGroup(
                        bedPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(bedNameScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 293, Short.MAX_VALUE)
                        .addComponent(bedScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 293, Short.MAX_VALUE)
                    );

                    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
                    this.setLayout(layout);
                    layout.setHorizontalGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addContainerGap()
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(staffPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(bedPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jPanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 1000, Short.MAX_VALUE))
                            .addContainerGap())
                    );
                    layout.setVerticalGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(staffPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(bedPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addContainerGap())
                    );
                }// </editor-fold>//GEN-END:initComponents

    private void printButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_printButtonActionPerformed
            //用紙サイズ、用紙方向の設定
            PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
            aset.add(MediaSizeName.ISO_A4);
            aset.add(OrientationRequested.LANDSCAPE);

            PrinterJob printJob = PrinterJob.getPrinterJob();
            printJob.setPrintable( this );
//            if (printJob.printDialog(aset)) {
                try {
                    //印刷処理
                    printJob.print(aset);
                } catch (Exception e) {
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
                }
//            }
    }//GEN-LAST:event_printButtonActionPerformed

	private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
		this.closePanel();
	}//GEN-LAST:event_closeButtonActionPerformed
	
	
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane bedNameScrollPane;
    private javax.swing.JTable bedNameTable;
    private javax.swing.JPanel bedPanel;
    private javax.swing.JScrollPane bedScrollPane;
    private com.geobeck.swing.JTableEx bedTable;
    private javax.swing.JButton closeButton;
    private jp.co.flatsoft.fscomponent.FSCalenderCombo date;
    private javax.swing.JLabel finishColorLabel;
    private javax.swing.JLabel finishLabel;
    private javax.swing.JPanel infoPanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel;
    private javax.swing.JLabel mobileColorLabel;
    private javax.swing.JLabel mobileLabel;
    private javax.swing.JButton printButton;
    private javax.swing.JLabel reserveColorLabel;
    private javax.swing.JLabel reserveLabel;
    private javax.swing.JScrollPane staffNameScrollPane;
    private javax.swing.JTable staffNameTable;
    private javax.swing.JPanel staffPanel;
    private javax.swing.JScrollPane staffScrollPane;
    private com.geobeck.swing.JTableEx staffTable;
    private javax.swing.JLabel stayColorLabel;
    private javax.swing.JLabel stayLabel;
    private com.geobeck.swing.ImageLabel title;
    // End of variables declaration//GEN-END:variables
        
 	/**
	 * ボタンにマウスカーソルが乗ったときにカーソルを変更するイベントを追加する。
	 */
	private void addMouseCursorChange()
	{
		SystemInfo.addMouseCursorChange(printButton);
		SystemInfo.addMouseCursorChange(closeButton);
	}

	/**
	 * 選択されている店舗のIDを取得する。
	 * @return 選択されている店舗のID
	 */
	private Integer getSelectedShopID()
	{
            Integer result = 0;
            
            MstShop ms = ts.getShop();
            if (ms != null) {
                result = ms.getShopID();
            }
            
            return result;
	}
	
	/**
	 * 指定店舗の開店閉店時間を取得する
	 */
	private void setOpenCloseTimeByReservation()
	{
		ConnectionWrapper	con	=	SystemInfo.getConnection();
		
		try
		{
			ResultSetWrapper	rs	=	con.executeQuery(this.getOpenCloseTimeSQL());
			
			if(rs.next())
			{
				openHour	=	rs.getInt("open_hour");     /** 開店時 */
				openMinute	=	rs.getInt("open_minute");   /** 開店分 */
//				closeHour	=	rs.getInt("open_hour") + 14;/** 閉店時(開店から14時間) */
//				closeMinute	=	rs.getInt("open_minute");   /** 閉店分(開店から14時間) */
				closeHour	=	rs.getInt("close_hour");/** 閉店時 */
				closeMinute	=	rs.getInt("close_minute");   /** 閉店分 */
				if(closeHour.compareTo(openHour +14) < 0){
				    closeHour = openHour + 14;
				    closeMinute = openMinute;
				}
			}
			
			rs.close();
		}
		catch(SQLException e)
		{
			SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
		}
	}
	
	/**
	 * 指定店舗の開店閉店時間を取得するSQL
	 */
	private String getOpenCloseTimeSQL()
	{
		return	"select\n" +
			"date_part('hour', open_time) as open_hour,\n" +
			"date_part('minute', open_time) as open_minute,\n" +
			"date_part('hour', close_time) +\n" +
			"case when date_part('day', open_time) != date_part('day', close_time) then 24\n" +
			"else 0 end as close_hour,\n" +
			"date_part('minute', close_time) as close_minute\n" +
			"from (\n" +
			"select\n" +
			"max(case when drd.open_time < ms.open_time then drd.open_time else ms.open_time end) as open_time,\n" +
			"max(case when drd.close_time > ms.close_time then drd.close_time else ms.close_time end) as close_time\n" +
			"from (\n" +
			"select\n" +
			"ms.shop_id,\n" +
			"ms.term,\n" +
			"to_timestamp(" + SQLUtil.convertForSQLDateOnly(currentDate) + ", 'YYYY/MM/DD') +\n" +
			"cast(ms.open_hour || ' hours' as interval) +\n" +
			"cast(ms.open_minute || ' minutes' as interval) as open_time,\n" +
			"to_timestamp(" + SQLUtil.convertForSQLDateOnly(currentDate) + ", 'YYYY/MM/DD') +\n" +
			"case when ms.close_hour < 24 then cast('0 days' as interval)\n" +
			"else cast('1 days' as interval) end +\n" +
			"cast(ms.close_hour || ' hours' as interval) +\n" +
			"cast(ms.close_minute || ' minutes' as interval) as close_time\n" +
			"from mst_shop ms\n" +
			") ms\n" +
			"left outer join (\n" +
			"select drd.shop_id,\n" +
			"drd.reservation_datetime as open_time,\n" +
			"drd.reservation_datetime + cast((coalesce(drd.operation_time, mt.operation_time) || ' minutes') as interval) as close_time\n" +
			"from data_reservation_detail drd\n" +
			"inner join mst_technic mt\n" +
			"on mt.technic_id = drd.technic_id\n" +
			"where drd.delete_date is null\n" +
			"and drd.shop_id = " + SQLUtil.convertForSQL(this.getSelectedShopID()) + "\n" +
			") drd\n" +
			"on drd.shop_id = ms.shop_id\n" +
			"and drd.close_time between ms.open_time and (ms.open_time + '1 days')\n" +
			"where ms.shop_id = " + SQLUtil.convertForSQL(this.getSelectedShopID()) + ") ms\n";
	}
	
	/**
	 * 指定店舗の開店閉店時間を取得する
	 */
	private void setOpenCloseTime()
	{
            if(currentDate == null) {
                openHour	=	ts.getShop().getOpenHour();         /** 開店時 */
                openMinute	=	ts.getShop().getOpenMinute();       /** 開店分 */
                closeHour	=	ts.getShop().getCloseHour();        /** 閉店時 */
                closeMinute	=	ts.getShop().getCloseMinute();      /** 閉店分 */
                if(closeHour.compareTo(openHour +14) < 0){
                    closeHour = openHour + 14;
                    closeMinute = openMinute;
                }
                // タイムスケジュールに開店〜閉店時間情報を設定する
                ts.setOpenHour(openHour);
                ts.setOpenMinute(openMinute);
                ts.setCloseHour(closeHour);
                ts.setCloseMinute(closeMinute);
            } else {
                ts.setOpenCloseTimeByReservation(currentDate);
                openHour	=	ts.getOpenHour();
                openMinute	=	ts.getOpenMinute();
                closeHour	=	ts.getCloseHour();
                closeMinute	=	ts.getCloseMinute();
            }
            ts.setTerm(term);
            
	}
	
	/**
	 * 列ヘッダ用の配列を取得する。
	 * @return 列ヘッダ用の配列
	 */
	private	Vector getHeaderTextArray()
	{
		Vector<String>	ht		=	new Vector<String>();
		
		if(openHour == null || closeHour == null || term == null )	return	ht;
		
		for(int h = openHour; h <= closeHour; h ++)
		{
			for(int m = 0; m < 60; m += term)
			{
				//開店時間より前の場合
				if(h == openHour && m < openMinute)
					continue;
				//閉店時間より後の場合
				if(h == closeHour && closeMinute <= m)
					break;
				
				//０分の時、時間をセット
				if(m == 0)	ht.add(Integer.toString(h) + ":00");
				else	ht.add("");
			}
		}
		
		return	ht;
	}
	
	/**
	 * JTableを初期化する
	 * @param table 
	 */
	private void initTable(JTable table)
	{
		table.setModel(new DefaultTableModel(this.getHeaderTextArray(), 0)
				{
					public boolean isCellEditable(int rowIndex, int columnIndex)
					{
						return false;
					}
				});
		table.getTableHeader().setReorderingAllowed(false);
		table.getTableHeader().setSize(staffTable.getTableHeader().getWidth(), ROW_HEIGHT);
		table.setRowHeight(ROW_HEIGHT);
		
		for(int col = 0; col < table.getColumnModel().getColumnCount(); col ++)
		{
			table.getColumnModel().getColumn(col).setPreferredWidth(COLUMN_WIDTH);
			table.getColumnModel().getColumn(col).setResizable(false);
		}
		
		SwingUtil.setJTableHeaderRenderer(table, SystemInfo.getTableHeaderRenderer());
	}
	
	/**
	 * データを読み込む。
	 */
	public void load()
	{
		currentDate.setTime(date.getDate());
		
		this.setOpenCloseTime();
		
		//テーブルを初期化
                this.initTable(staffTable);
                this.initTable(bedTable);
		
		//データを読み込む
		if(!ts.load(currentDate.getTime()))
		{
			return;
		}
		
		//データを表示
		this.showData();
	}
	
	/**
	 * データを表示する。
	 */
	private void showData()
	{
		this.showData(ts.getStaffs(), staffScrollPane, staffNameTable, staffTable);
		this.showData(ts.getBeds(), bedScrollPane, bedNameTable, bedTable);
	}
	
	/**
	 * データを表示する。
	 * @param headers ヘッダデータリスト
	 * @param scrollPane スクロールペイン
	 * @param headerTable ヘッダ用テーブル
	 * @param table データ用テーブル
	 */
	private void showData(ArrayList<ReservationHeader> headers,
			JScrollPane scrollPane,
			JTable headerTable, JTable table)
	{
		SwingUtil.clearTable(headerTable);
		SwingUtil.clearTable(table);
		headerTable.removeAll();
		table.removeAll();
		
		int	headerRow	=	0;
		int	headerRows	=	0;
		
		for(ReservationHeader rh : headers)
		{
			//ヘッダーデータを追加
			this.addHeader(headerTable, table, rh, headerRow);
			headerRows =	1;
			
			//予約データを追加
			for(ReservationJTextField rtf: rh.getReservations())
			{
                            headerRows = this.addReservation(
                                                headers,
                                                scrollPane,
                                                headerTable,
                                                table,
                                                rtf,
                                                headerRow,
                                                headerRows);
			}
			
			headerRow += headerRows;
		}
	}
	
	/**
	 * ヘッダをヘッダ用テーブルに追加する。
	 * @param headerTable ヘッダ用テーブル
	 * @param table データ用テーブル
	 * @param rh 予約ヘッダデータ
	 * @param headerRow 追加する行
	 */
	private void addHeader(JTable headerTable, JTable table,
			ReservationHeader rh, int headerRow)
	{
            DefaultTableModel	hModel	=	(DefaultTableModel)headerTable.getModel();
            Vector<Object>	v	=	new Vector<Object>();
            v.add("");
            hModel.addRow(v);

            // タイムテーブルに行を追加
            TimeTableDrawer.makeNewRow(ts.getShop(), ts, rh, table);

            rh.setLocation(0, ROW_HEIGHT * headerRow);
            rh.setSize(HEADER_WIDTH, ROW_HEIGHT);
            rh.setBorder(javax.swing.BorderFactory.createLineBorder(TimeTableDrawer.COLOR_BORDER));
            rh.setBackground(TimeTableDrawer.COLOR_HEADER);
            rh.setEditable(false);
            headerTable.add(rh);
	}
	
	/**
	 * 時間からｘ座標を取得する。
	 * @param hour 時
	 * @param minute 分
	 * @return 時間に対応するｘ座標
	 */
	private int getLeft(int hour, int minute)
	{
		int	left	=	0;
		
		left	+=	(hour - openHour) * 60 / term * COLUMN_WIDTH;
		left	+=	(minute - openMinute) / term * COLUMN_WIDTH;
		
		return	left;
	}
	
	/**
	 * JTextFieldの色を取得する。
	 * @param status 状態
	 * @return JTextFieldの色
	 */
	private Color getColor(int status)
	{
		switch(status)
		{
			//予約
			case 1:
				return	COLOR_RESERVATION;
			//在店
			case 2:
				return	COLOR_STAY;
			//退店
			case 3:
				return	COLOR_FINISH;
			default:
				return	new Color(0x000000);
		}
	}
	
	/**
	 * ヘッダの高さを１行分増やす。
	 * @param headers ヘッダデータリスト
	 * @param headerTable ヘッダ用テーブル
	 * @param table データ用テーブル
	 * @param header ヘッダデータ
	 */
	private void addHeaderHeight(ArrayList<ReservationHeader> headers,
			JTable headerTable, JTable table,
			ReservationHeader header)
	{
            header.setSize(header.getWidth(), header.getHeight() + ROW_HEIGHT);

            //ヘッダを1行追加
            DefaultTableModel hModel = (DefaultTableModel)headerTable.getModel();
            Vector<Object> v = new Vector<Object>();
            v.add("");
            hModel.addRow(v);

            // タイムテーブルに追加行を追加
            TimeTableDrawer.makeAddRow(ts.getShop(), ts, header, table);

            //下のデータの位置を全てずらす
            for(ReservationHeader rh : headers) {
                if(header.getY() < rh.getY()) {
                    rh.setLocation(rh.getX(), rh.getY() + ROW_HEIGHT);

                    for(ReservationJTextField rtf : rh.getReservations()) {
                        rtf.setLocation(rtf.getX(), rtf.getY() + ROW_HEIGHT);
                        rtf.repaint();
                    }
                }
            }
            
	}
	
	/**
	 * 予約をテーブルに追加する。
	 * @param headerTable ヘッダ用テーブル
	 * @param table データ用テーブル
	 * @param rtf タイムスケジュール画面用JTextField
	 * @param headerRow ヘッダの行
	 * @param headerRows ヘッダの行数
	 * @return ヘッダの行数
	 */
	private int addReservation(final ArrayList<ReservationHeader> headers,
			final JScrollPane scrollPane,
			final JTable headerTable, final JTable table,
			ReservationJTextField rtf, int headerRow, int headerRows)
	{
		//サイズを設定
//                Integer currentShopTerm = SystemInfo.getCurrentShop().getTerm();
	        Integer currentShopTerm = ts.getShop().getTerm();
		rtf.setSize(currentShopTerm, COLUMN_WIDTH * currentShopTerm / term, ROW_HEIGHT - 1);
		//位置を設定
		rtf.setLocation(this.getLeft(rtf.getHour(currentDate.getTime()), rtf.getMinute()), ROW_HEIGHT * headerRow);
		
		//データが重複しないように配置する
		for (int i = 1; i <= headerRows; i ++) {

                    //重複するデータが存在する場合
                    if (this.isExistOverlapData(rtf, false)) {
                        if (i == headerRows) {
                            //行を1行追加
                            this.addHeaderHeight(headers, headerTable, table, rtf.getHeader());
                            headerRows ++;
                        }

                        rtf.setLocation(rtf.getX(), rtf.getY() + ROW_HEIGHT);
                    } else {
                        break;
                    }
		}
		
		rtf.setBackground(this.getColor(rtf.getReservation().getStatus()));

		if (rtf.getReservation().getMobileFlag() != 0) {
                    rtf.setBackground(COLOR_MOBILE);//背景色設定
                    rtf.setBorder(null);
		} else {
                    rtf.setBorder(null);
		}               
		
		table.add(rtf);
		
		return headerRows;
	}
	
	/**
	 * ｘ座標から対応する時間のCalendarを取得する。
	 * @param x ｘ座標
	 * @return Calendar
	 */
	private GregorianCalendar getCalendar(int x)
	{
		GregorianCalendar temp = (GregorianCalendar)currentDate.clone();
		
		Integer	hour	=	openHour + (x / COLUMN_WIDTH - (60 - (openMinute == 0 ? 60 :openMinute)) / term) / (60 / term);
		Integer	minute	=	(((60 - openMinute) / term + x / COLUMN_WIDTH) % (60 / term)) * term;
		temp.set(temp.HOUR_OF_DAY, hour);
		temp.set(temp.MINUTE, minute);
		
		return	temp;
	}
	
	/**
	 * 時間が重複するデータが存在するかを返す。
	 * @param reservation 予約データ
	 * @param isCheckOtherRow true - 他の行もチェックする。
	 * @return true - 時間が重複するデータが存在する
	 */
	private boolean isExistOverlapData(ReservationJTextField reservation, boolean isCheckOtherRow) {
            
            ReservationHeader rh = reservation.getHeader();
		
            for (ReservationJTextField rtf : rh.getReservations()) {
                if (!rtf.equals(reservation)) {
                    if (!isCheckOtherRow && rtf.getY() != reservation.getY()) {
                        continue;
                    }
				
                    if ((rtf.getX() < reservation.getX() &&
                            reservation.getX() < rtf.getX() + rtf.getWidth()) ||
                            (rtf.getX() < reservation.getX() + reservation.getWidth() &&
                            reservation.getX() < rtf.getX() + rtf.getWidth())) {
                        return true;
                    }
                }
            }
            return false;
	}
	
	/**
	 * ダイアログを閉じる
	 */
	private void closePanel() {
            if(this.isDialog()) {
                ((JDialog)this.getParent().getParent().getParent().getParent()).setVisible(false);
            } else {
                this.setVisible(false);
            }
	}

	/**
	 * 画面を印刷する
	 * @param g 描画クラス
	 * @param pf ページフォーマット
	 * @param pi ページインデックス
	 * @return int 1：NO_SUCH_PAGE 0：PAGE_EXISTS
	 */
        public int print( Graphics g, PageFormat pf, int pi ) throws PrinterException {
            if ( pi >= 1 ) {
                return Printable.NO_SUCH_PAGE;
            }
            Graphics2D g2 = (Graphics2D)g;

            //左・上のマージン分をずらして描画する
            g2.translate( (int)pf.getImageableX(), (int)pf.getImageableY() );
            g2.scale(SCALE, SCALE);

            this.printAll(g2);
            return Printable.PAGE_EXISTS;
        }
}
