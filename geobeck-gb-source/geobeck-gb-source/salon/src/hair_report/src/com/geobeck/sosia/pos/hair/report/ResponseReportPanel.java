/*
 * ResponseReportPanel.java
 *
 * Created on 2007/08/30, 20:25
 */

package com.geobeck.sosia.pos.hair.report;

import java.awt.*;
import java.sql.*;
import java.util.*;
import java.util.logging.*;
import javax.swing.*;
import javax.swing.text.*;
import com.geobeck.sql.*;
import com.geobeck.util.*;
import com.geobeck.swing.*;
import com.geobeck.sosia.pos.util.*;
import com.geobeck.sosia.pos.system.*;
import com.geobeck.sosia.pos.master.company.*;
import com.geobeck.sosia.pos.hair.master.company.*;

/**
 *
 * @author  kanemoto
 */
public class ResponseReportPanel extends com.geobeck.sosia.pos.swing.AbstractImagePanelEx {
//    private MstShop myShop = null;
    
    /** Creates new form ResponseReportPanel */
    public ResponseReportPanel( MstShop myShop ) {
                
//	this.myShop = myShop;
	initComponents();
	addMouseCursorChange();
	this.setSize(600, 400);
	this.setPath("帳票出力");
	this.setTitle("レスポンス分析");
	this.setKeyListener();
	SystemInfo.initGroupShopComponents(target, 3);
	init();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        rank = new javax.swing.ButtonGroup();
        sheetType = new javax.swing.ButtonGroup();
        rankView = new javax.swing.ButtonGroup();
        pnlMain = new javax.swing.JPanel();
        lblTargetPeriod = new javax.swing.JLabel();
        target = new com.geobeck.sosia.pos.swing.JComboBoxLabel();
        staffLabel1 = new javax.swing.JLabel();
        targetStartDate = new jp.co.flatsoft.fscomponent.FSCalenderCombo();
        targetEndDate = new jp.co.flatsoft.fscomponent.FSCalenderCombo();
        jLabel2 = new javax.swing.JLabel();
        lblTargetPeriod1 = new javax.swing.JLabel();
        txtFixedCount = new javax.swing.JTextField();
        ((PlainDocument)txtFixedCount.getDocument()).setDocumentFilter(
            new CustomFilter(3, CustomFilter.NUMERIC));
        lblTargetPeriod5 = new javax.swing.JLabel();
        btnOutput = new javax.swing.JButton();

        pnlMain.setFocusCycleRoot(true);
        pnlMain.setOpaque(false);

        lblTargetPeriod.setText("固定回数");
        lblTargetPeriod.setFocusCycleRoot(true);

        //shop.addItem(this.myShop);

        staffLabel1.setText("対象");

        targetStartDate.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        targetStartDate.setDate(new java.util.Date());

        targetEndDate.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        targetEndDate.setDate(new java.util.Date());

        jLabel2.setText("〜");
        jLabel2.setFocusCycleRoot(true);

        lblTargetPeriod1.setText("対象期間");
        lblTargetPeriod1.setFocusCycleRoot(true);

        txtFixedCount.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        txtFixedCount.setText("3");

        lblTargetPeriod5.setText("回以上");

        javax.swing.GroupLayout pnlMainLayout = new javax.swing.GroupLayout(pnlMain);
        pnlMain.setLayout(pnlMainLayout);
        pnlMainLayout.setHorizontalGroup(
            pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlMainLayout.createSequentialGroup()
                .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlMainLayout.createSequentialGroup()
                        .addComponent(staffLabel1)
                        .addGap(55, 55, 55)
                        .addComponent(target, javax.swing.GroupLayout.PREFERRED_SIZE, 163, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(pnlMainLayout.createSequentialGroup()
                        .addComponent(lblTargetPeriod1)
                        .addGap(31, 31, 31)
                        .addComponent(targetStartDate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(4, 4, 4)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(targetEndDate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(pnlMainLayout.createSequentialGroup()
                        .addComponent(lblTargetPeriod)
                        .addGap(31, 31, 31)
                        .addComponent(txtFixedCount, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblTargetPeriod5, javax.swing.GroupLayout.DEFAULT_SIZE, 159, Short.MAX_VALUE)))
                .addContainerGap())
        );
        pnlMainLayout.setVerticalGroup(
            pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlMainLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(staffLabel1)
                    .addComponent(target, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblTargetPeriod1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 23, Short.MAX_VALUE)
                    .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(targetEndDate, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(targetStartDate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblTargetPeriod)
                    .addComponent(txtFixedCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblTargetPeriod5, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(231, 231, 231))
        );

        btnOutput.setIcon(SystemInfo.getImageIcon("/button/print/excel_off.jpg"));
        btnOutput.setBorderPainted(false);
        btnOutput.setContentAreaFilled(false);
        btnOutput.setFocusCycleRoot(true);
        btnOutput.setPressedIcon(SystemInfo.getImageIcon("/button/print/excel_on.jpg"));
        btnOutput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOutputActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pnlMain, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnOutput, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(143, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(pnlMain, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnOutput, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(78, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * ボタンにマウスカーソルが乗ったときにカーソルを変更するイベントを追加する。
     */
    private void addMouseCursorChange()
    {
	    SystemInfo.addMouseCursorChange(btnOutput);
    }

    private void setKeyListener()
    {
	    targetStartDate.addKeyListener(SystemInfo.getMoveNextField());
	    targetStartDate.addFocusListener(SystemInfo.getSelectText());
	    targetEndDate.addKeyListener(SystemInfo.getMoveNextField());
	    targetEndDate.addFocusListener(SystemInfo.getSelectText());
	    txtFixedCount.addKeyListener(SystemInfo.getMoveNextField());
	    txtFixedCount.addFocusListener(SystemInfo.getSelectText());
    }
	
    /**
     * 発行型の絞込み選択
     */
    private void btnOutputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOutputActionPerformed

        if (!SystemInfo.checkAuthorityPassword(280)) return;
        
        reportOutPut();
    }//GEN-LAST:event_btnOutputActionPerformed
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnOutput;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel lblTargetPeriod;
    private javax.swing.JLabel lblTargetPeriod1;
    private javax.swing.JLabel lblTargetPeriod5;
    private javax.swing.JPanel pnlMain;
    private javax.swing.ButtonGroup rank;
    private javax.swing.ButtonGroup rankView;
    private javax.swing.ButtonGroup sheetType;
    private javax.swing.JLabel staffLabel1;
    private com.geobeck.sosia.pos.swing.JComboBoxLabel target;
    private jp.co.flatsoft.fscomponent.FSCalenderCombo targetEndDate;
    private jp.co.flatsoft.fscomponent.FSCalenderCombo targetStartDate;
    private javax.swing.JTextField txtFixedCount;
    // End of variables declaration//GEN-END:variables
	
    private		int		beforeResopnseType	    =	    0;	    // レスポンスタイプ 0:全て 1:スタッフ配布型 2:フリーペーパー型
    private		ArrayList<MstResponse>	mrs	=	new	ArrayList<MstResponse>();
    private		int[]		arrayOutResponse	=	null;
    
    /**
     * 初期化を行う
     */
    private void init()
    {
		beforeResopnseType = -1;
		refreshResponseList();
    }
    
    /**
     * レスポンス項目リストを取得する
     */
    private void refreshResponseList()
    {
	    ResultSetWrapper	rs;
	    mrs.clear();
	    try
	    {
		    rs	=	SystemInfo.getConnection().executeQuery(this.getResponseListSelectSQL());
		    while( rs.next() )
		    {
			    MstResponse mr = new MstResponse();
			    mr.setData( rs );
			    mrs.add( mr );
		    }
		    rs.close();
	    }
	    catch(SQLException e)
	    {
		    SystemInfo.getLogger().log(Level.SEVERE, e.getLocalizedMessage(), e);
	    }
	    // レスポンスリストをテーブルに登録する
//	    showResponseList();
    }
    
    /**
     * レスポンス項目リスト取得SQLを取得する
     */
    private String getResponseListSelectSQL()
    {
	    return
		"select\n" +
		"*\n" +
		"from\n" +
		"mst_response as mr\n" +
		"where\n" +
		"mr.delete_date is null\n" +
//		( 0 < responseType.getSelectedIndex() ? "and mr.circulation_type = " + responseType.getSelectedIndex() + "\n" : "" ) +
		"order by response_id\n" +
		";\n";
    }
    
    /**
     * レポート出力を行う
     */
    private void reportOutPut()
    {
	    // 入力チェックを行う
	    if( !checkInput() ) return;
	    // 出力を行う
            //IVS_LVTu start edit 2016/02/24 New request #48455
             btnOutput.setCursor(null);
            try{
                setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                print();
            }catch(Exception e) {
                
            }finally{
                setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
            }
            //IVS_LVTu end edit 2016/02/24 New request #48455
    }
    
    /**
     * 入力チェックを行う
     */
    private boolean checkInput()
    {
	    // 対象期間 必須チェック
	    if (this.targetStartDate.getDate() == null) {
		MessageDialog.showMessageDialog(this,
		    MessageUtil.getMessage(MessageUtil.ERROR_INPUT_EMPTY, "集計期間"),
		    this.getTitle(),
		    JOptionPane.ERROR_MESSAGE);
		this.targetStartDate.requestFocusInWindow();
		return false;
	    }

	    if (this.targetEndDate.getDate() == null) {
		MessageDialog.showMessageDialog(this,
		    MessageUtil.getMessage(MessageUtil.ERROR_INPUT_EMPTY, "集計期間"),
		    this.getTitle(),
		    JOptionPane.ERROR_MESSAGE);
		this.targetEndDate.requestFocusInWindow();
		return false;
	    }

	    //固定回数 必須チェック
	    if(txtFixedCount.getText().equals(""))
	    {
		    MessageDialog.showMessageDialog(this,
				    MessageUtil.getMessage(MessageUtil.ERROR_INPUT_EMPTY, "固定回数"),
				    this.getTitle(),
				    JOptionPane.ERROR_MESSAGE);
		    txtFixedCount.requestFocusInWindow();
		    return false;
	    }
	    
	    //固定回数 数値チェック
	    if(!txtFixedCount.getText().equals("") && !CheckUtil.isNumber(txtFixedCount.getText()))
	    {
		    MessageDialog.showMessageDialog(this,
				    MessageUtil.getMessage(MessageUtil.ERROR_INPUT_WRONG, "固定回数"),
				    this.getTitle(),
				    JOptionPane.ERROR_MESSAGE);
		    txtFixedCount.requestFocusInWindow();
		    return false;
	    }
	    
	    return true;
    }
    
    private GregorianCalendar dateToGregorianCalendar( java.util.Date date )
    {
	    GregorianCalendar gCal = new GregorianCalendar();
	    gCal.setTime( date );
	    return gCal;
    }
    
    /**
     * レポートの出力を行う
     */
    private void print()
    {
	    ResponseReport rr = new ResponseReport();
	    Calendar cal = Calendar.getInstance();
            //グループ
            if(target.getSelectedItem() instanceof MstGroup)
            {
                    MstGroup	mg	=	(MstGroup)target.getSelectedItem();
                    rr.setTargetName(mg.getGroupName());
                    rr.setShopIDList(mg.getShopIDListAll());
            }
            //店舗
            else if(target.getSelectedItem() instanceof MstShop)
            {
                    MstShop		ms	=	(MstShop)target.getSelectedItem();
                    rr.setTargetName(ms.getShopName());
                    rr.setShopIDList(ms.getShopID().toString());
            }
	    
	    rr.setTargetStartDate( dateToGregorianCalendar( this.targetStartDate.getDate() ) );
	    rr.setTargetEndDate( dateToGregorianCalendar( this.targetEndDate.getDate() ) );
	    rr.setFixedCount( new Integer(this.txtFixedCount.getText()) );

	    rr.setReportData();
	    
	    // データが存在しない場合には出力を行わない
	    if( 0 < rr.size() )
	    {
		// 帳票を出力する
		rr.print();
	    }
	    else
	    {
		MessageDialog.showMessageDialog(this,
				MessageUtil.getMessage(1112, "表示レコード無し"),
				this.getTitle(),
				JOptionPane.ERROR_MESSAGE);
	    }
    }
    
	/**
	 * 業務報告画面用FocusTraversalPolicy
	 */
	private class BusinessReportFocusTraversalPolicy
					extends FocusTraversalPolicy
	{
		/**
		 * aComponBusinessReportFocusTraversalPolicy。
		 * aContainer は aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダでなければなりません。
		 * @param aContainer aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @param aComponent aContainer のおそらく間接的な子、または aContainer 自体
		 * @return aComponent のあとにフォーカスを受け取る Component。適切な Component が見つからない場合は null
		 */
		public Component getComponentAfter(Container aContainer, Component aComponent)
		{
			if (aComponent.equals(targetStartDate))
                        {
				return targetEndDate;
			}
			else if (aComponent.equals(targetEndDate))
			{
				return txtFixedCount;
			}
                    
			return txtFixedCount;
		}

		/**
		 * aComponent の前にフォーカスを受け取る Component を返します。
		 * aContainer は aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダでなければなりません。
		 * @param aContainer aComponent のフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @param aComponent aContainer のおそらく間接的な子、または aContainer 自体
		 * @return aComponent の前にフォーカスを受け取る Component。適切な Component が見つからない場合は null
		 */
		public Component getComponentBefore(Container aContainer, Component aComponent)
		{
                        if (aComponent.equals(txtFixedCount))
			{
				return targetEndDate;
                                
			}
			else if (aComponent.equals(targetEndDate))
			{
				return targetStartDate;
			}
			
			return targetStartDate;
		}

		/**
		 * トラバーサルサイクルの最初の Component を返します。
		 * このメソッドは、順方向のトラバーサルがラップするときに、次にフォーカスする Component を判定するために使用します。
		 * @param aContainer 先頭の Component を返すフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @return aContainer のトラバーサルサイクルの先頭の Componet、または適切な Component が見つからない場合は null
		 */
		public Component getFirstComponent(Container aContainer)
		{
			return targetStartDate;
		}

		/**
		 * トラバーサルサイクルの最後の Component を返します。
		 * このメソッドは、逆方向のトラバーサルがラップするときに、次にフォーカスする Component を判定するために使用します。
		 * @param aContainer aContainer - 最後の Component を返すフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @return aContainer のトラバーサルサイクルの最後の Componet、または適切な Component が見つからない場合は null
		 */
		public Component getLastComponent(Container aContainer)
		{
			return txtFixedCount;
		}

		/**
		 * フォーカスを設定するデフォルトコンポーネントを返します。
		 * aContainer をルートとするフォーカストラバーサルサイクルが新しく開始されたときに、このコンポーネントに最初にフォーカスが設定されます。
		 * @param aContainer デフォルトの Component を返すフォーカスサイクルのルートまたはフォーカストラバーサルポリシープロバイダ
		 * @return aContainer のトラバーサルサイクルのデフォルトの Componet、または適切な Component が見つからない場合は null
		 */
		public Component getDefaultComponent(Container aContainer)
		{
			return targetStartDate;
		}
		
		/**
		 * ウィンドウが最初に表示されたときにフォーカスが設定されるコンポーネントを返します。
		 * show() または setVisible(true) の呼び出しで一度ウィンドウが表示されると、
		 * 初期化コンポーネントはそれ以降使用されません。
		 * 一度別のウィンドウに移ったフォーカスが再び設定された場合、
		 * または、一度非表示状態になったウィンドウが再び表示された場合は、
		 * そのウィンドウの最後にフォーカスが設定されたコンポーネントがフォーカス所有者になります。
		 * このメソッドのデフォルト実装ではデフォルトコンポーネントを返します。
		 * @param window 初期コンポーネントが返されるウィンドウ
		 * @return 最初にウィンドウが表示されるときにフォーカス設定されるコンポーネント。適切なコンポーネントがない場合は null
		 */
		public Component getInitialComponent(Window window)
		{
			return targetStartDate;
		}
		
	}    
}
